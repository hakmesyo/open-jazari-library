/**
 * B. CMatrix class is a core class of Open Cezeri Library (OCL) and it is
 * implemented by Dr.Musa ATAÅž who is the instructor and principal coordinator
 * at the Department of Computer Engineering and so called El-Cezeri Cybernetics
 * and Vision Laboratory, respectively.
 *
 * Important Remarks(last updated at 04.11.2014)
 *
 * 1- Note that CMatrix is implemented as a Static Factory Design Pattern
 * approach. Therefore you can not build an object directly via the constructor.
 * Rather, instance or object can be generated by calling getInstance methods
 * and its overloaded methods. For example CMatrix obj=new CMatrix() is not
 * working, hence instead of this type of calling convention try to type
 * CMatrix.getInstance(); or any other variants of getInstance.
 *
 * 2- Almost all methods of CMatrix returns CMatrix even if you want to use
 * image processing or any other specialized classes. Users in fact doesn't know
 * which external classes are used and what's the algorithms inside the calling
 * methods.
 *
 * 3- In some cases, especially in the case of deep learning, builder pattern is
 * proposed. As a result, until the build() command CMatrix does not returned
 * from any subsequent builder methods.
 *
 * 4- if you encounter the github push authentication not supported problem
 * try this
 *
 * --locale on some Windows platforms makes netbeans crash. Preffer to use "-J-Duser.language=en -J-Duser.region=US"
 *
 * Find netbeans etc, likely at the C:\Program Files\NetBeans 7.3\etc
 * Open netbeans.conf
 * Find netbeans_default_options
 * Add those options, so: netbeans_default_options="blablabla -J-Duser.language=en -J-Duser.region=US"
 * Save file
 * Restart/start netbeans.
 * https://blogs.oracle.com/tao/entry/set_netbeans_user_interface_language
 *
 */
package jazari.matrix;

import ai.djl.Application;
import ai.djl.MalformedModelException;
import ai.djl.Model;
import ai.djl.basicdataset.cv.classification.ImageFolder;
import ai.djl.inference.Predictor;
import ai.djl.metric.Metrics;
import ai.djl.modality.Classifications;
import ai.djl.modality.cv.Image;
import ai.djl.modality.cv.ImageFactory;
import ai.djl.modality.cv.transform.Normalize;
import ai.djl.modality.cv.transform.Resize;
import ai.djl.modality.cv.transform.ToTensor;
import ai.djl.modality.cv.translator.ImageClassificationTranslator;
import ai.djl.ndarray.types.Shape;
import ai.djl.nn.Block;
import ai.djl.repository.zoo.Criteria;
import ai.djl.repository.zoo.ModelNotFoundException;
import ai.djl.training.EasyTrain;
import ai.djl.training.Trainer;
import ai.djl.training.TrainingConfig;
import ai.djl.training.TrainingResult;
import ai.djl.training.dataset.RandomAccessDataset;
import ai.djl.training.loss.Loss;
import ai.djl.translate.TranslateException;
import ai.djl.translate.Translator;
import jazari.interfaces.call_back_interface.CallBackDataBase;
import jazari.factory.FactoryCombination;
import jazari.factory.FactoryMatrix;
import jazari.types.TMatrixOperator;
import jazari.types.TMatrixCell;
import jazari.machine_learning.extraction.FeatureExtractionLBP;
import jazari.machine_learning.extraction.FeatureExtractionPistachio;
import jazari.machine_learning.extraction.FeatureExtractionRingProjection;
import jazari.gui.FrameBar;
import jazari.gui.FrameDataGrid;
import jazari.gui.FrameHeatMap;
import jazari.gui.FrameHistogram;
import jazari.gui.FramePlot;
import jazari.gui.FrameScatterPlot;
import jazari.gui.FrameImageHistogram;
import jazari.gui.FrameImage;
import jazari.types.TFigureAttribute;
import jazari.image_processing.GrayScale;
import jazari.image_processing.ImageProcess;
import jazari.image_processing.SobelEdgeDetector;
import jazari.utils.ReaderCSV;
import jazari.factory.FactoryNormalization;
import jazari.factory.FactoryPermutation;
import jazari.factory.FactorySocket;
import jazari.factory.FactoryUtils;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Polygon;
import java.awt.Rectangle;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.InputMismatchException;
import java.util.List;
import java.util.Random;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JFrame;
import org.opencv.core.Mat;
import jazari.transform.TransformFFT;
import jazari.transform.TransformRadon;
import jazari.utils.BruteForce;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.converters.ConverterUtils;
import weka.core.matrix.EigenvalueDecomposition;
import weka.core.matrix.Matrix;
import java.security.SecureRandom;
import jazari.interfaces.InterfaceCallBack;
import jazari.enums.EnumEngine;
import jazari.enums.EnumOperatingSystem;
import jazari.enums.EnumRunTime;
import jazari.factory.FactoryDJL;
import jazari.factory.FactoryDataBase;
import jazari.factory.FactoryTensorFlowJS;
import jazari.factory.FactoryWebCam;
import jazari.gui.FrameScatterBlob;
import jazari.gui.FramePloty;
import jazari.types.TBlockType;
import jazari.types.TDJLModel;
import jazari.types.TRoi;
import jazari.websocket.SocketServer;
import java.net.MalformedURLException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.stream.IntStream;
import javax.swing.JPanel;
import jazari.utils.DataAugmentationOpt;
import org.nd4j.linalg.api.ndarray.INDArray;
import org.nd4j.linalg.cpu.nativecpu.NDArray;
import org.nd4j.linalg.factory.Nd4j;
import org.nd4j.linalg.indexing.INDArrayIndex;
import org.nd4j.linalg.indexing.NDArrayIndex;
import org.nd4j.linalg.inverse.InvertMatrix;
import org.nd4j.linalg.ops.transforms.Transforms;

/**
 *
 * @author BAP1
 */
public final class CMatrix implements Serializable {

    public String name = "Matrix";
//    private float[][] array;
    transient private BufferedImage image;
    private String imagePath = "";
//    private CMatrix prevMatrix;
//    private CMatrix nextMatrix;
    public CReturn returnedValue;
    private static long currentTime = System.nanoTime();
    private boolean hold_on = false;
    private Instances wekaInstance = null;
    public FrameImage frameImage = null;
    private FramePlot framePlot = null;
    private FramePloty framePloty = null;
    private FrameHeatMap frameHeatMap = null;
    public String plotType = "-";
    private List<String> columnNames = new ArrayList();
    private List classLabels = new ArrayList();
    private float[] xData4FX;
//    private static Random random = new SecureRandom();
    private Random random = new SecureRandom();
    private List classLabelValues = new ArrayList();
    private List classLabelNames = new ArrayList();
    public String[] combinationPairs;
    public String[] permutationPairs;
    public static CMatrix currentMatrix = null;
    private boolean isArraySet = false;
    private Translator<Image, Classifications> translator;
    private Predictor<Image, Classifications> predictor;
    private Model model;
    private String MODEL_NAME;
    private int NUM_CHANNEL;
    private int NUM_OUTPUT;
    private int IMAGE_WIDTH;
    private int IMAGE_HEIGHT;
    private int BLOCK_TYPE;
    private Block BLOCK;
    public SocketServer TENSORFLOW_JS_SERVER;
    public InterfaceCallBack icbf;
    public JPanel plotPanel;
    public INDArray array;

    public CMatrix getCurrentMatrix() {
        return currentMatrix;
    }
    public int[] shuffleIndexes;

    public CMatrix buildFrameImage() {
        if (frameImage == null) {
            frameImage = new FrameImage();
            frameImage.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        }
        return this;
    }

    public CMatrix buildFramePlot() {
        if (framePlot == null) {
            framePlot = new FramePlot(this);
            framePlot.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        }
        return this;
    }

    public Instances getWekaInstance() {
        return wekaInstance;
    }

    public CMatrix setWekaInstance(Instances wekaInstance) {
        this.wekaInstance = wekaInstance;
        this.wekaInstance.setClassIndex(this.wekaInstance.numAttributes() - 1);
        return CMatrix.fromInstances(this.wekaInstance);
    }

    public int getRowNumber() {
        return (int) array.shape()[0];
    }

    public int getColumnNumber() {
        return (int) array.shape()[1];
    }

    public BufferedImage getImage() {
        return image;
    }

    public CMatrix setImage(BufferedImage image) {
        this.image = image;
        this.array = Nd4j.create(ImageProcess.imageToPixelsFloat(GrayScale.luminosity(this.image)));
        return this;
    }

    /**
     * Easy integer array generation (note that these methods do not return
     * instance of CMatrix
     *
     * @param length
     * @return int[]
     */
    public static int[] intArray1D(int length) {
        int[] ret = new int[length];
        return ret;
    }

    /**
     * Easy integer array generation (note that these methods do not return
     * instance of CMatrix
     *
     * @param length
     * @param value
     * @return int[]
     */
    public static int[] intArray1D(int length, int value) {
        int[] ret = new int[length];
        for (int i = 0; i < length; i++) {
            ret[i] = value;
        }
        return ret;
    }

    /**
     * Easy integer array generation (note that these methods do not return
     * instance of CMatrix
     *
     * @param from
     * @param to
     * @param step
     * @return int[]
     */
    public static int[] intArray1D(int from, int to, int step) {
        int length = (int) ((to - from) / step) + 1;
        int[] ret = new int[length];
        for (int i = 0; i < length; i++) {
            ret[i] = from + i * step;
        }
        return ret;
    }

    /**
     * Easy float array generation (note that these methods do not return
     * instance of CMatrix
     *
     * @param length
     * @return float[]
     */
    public static float[] floatArray1D(int length) {
        float[] ret = new float[length];
        return ret;
    }

    /**
     * Easy float array generation (note that these methods do not return
     * instance of CMatrix
     *
     * @param length
     * @param value
     * @return float[]
     */
    public static float[] floatArray1D(int length, float value) {
        float[] ret = new float[length];
        for (int i = 0; i < length; i++) {
            ret[i] = value;
        }
        return ret;
    }

    /**
     * Easy float array generation (note that these methods do not return
     * instance of CMatrix
     *
     * @param from
     * @param to
     * @param step
     * @return float[]
     */
    public static float[] floatArray1D(float from, float to, float step) {
        int length = (int) ((to - from) / step);
        float[] ret = new float[length];
        for (int i = 0; i < length; i++) {
            ret[i] = from + i * step;
        }
        return ret;
    }

    /**
     * Easy double array generation (note that these methods do not return
     * instance of CMatrix
     *
     * @param length
     * @return double[]
     */
    public static double[] doubleArray1D(int length) {
        double[] ret = new double[length];
        return ret;
    }

    /**
     * Easy double array generation (note that these methods do not return
     * instance of CMatrix
     *
     * @param length
     * @param value
     * @return double[]
     */
    public static double[] doubleArray1D(int length, double value) {
        double[] ret = new double[length];
        for (int i = 0; i < length; i++) {
            ret[i] = value;
        }
        return ret;
    }

    /**
     * Easy double array generation (note that these methods do not return
     * instance of CMatrix
     *
     * @param from
     * @param to
     * @param step
     * @return double[]
     */
    public static double[] doubleArray1D(double from, double to, double step) {
        int length = (int) ((to - from) / step);
        double[] ret = new double[length];
        for (int i = 0; i < length; i++) {
            ret[i] = from + i * step;
        }
        return ret;
    }

    /**
     * Easy long array generation (note that these methods do not return
     * instance of CMatrix
     *
     * @param length
     * @return long[]
     */
    public static long[] longArray1D(int length) {
        long[] ret = new long[length];
        return ret;
    }

    /**
     * Easy long array generation (note that these methods do not return
     * instance of CMatrix
     *
     * @param length
     * @param value
     * @return long[]
     */
    public static long[] longArray1D(int length, long value) {
        long[] ret = new long[length];
        for (int i = 0; i < length; i++) {
            ret[i] = value;
        }
        return ret;
    }

    /**
     * Easy long array generation (note that these methods do not return
     * instance of CMatrix
     *
     * @param from
     * @param to
     * @param step
     * @return long[]
     */
    public static long[] longArray1D(int from, int to, int step) {
        int length = (to - from) / step;
        long[] ret = new long[length];
        for (int i = 0; i < length; i++) {
            ret[i] = from + i * step;
        }
        return ret;
    }

    /**
     * Easy byte array generation (note that these methods do not return
     * instance of CMatrix
     *
     * @param length
     * @return byte[]
     */
    public static byte[] byteArray1D(int length) {
        byte[] ret = new byte[length];
        return ret;
    }

    /**
     * Easy byte array generation (note that these methods do not return
     * instance of CMatrix
     *
     * @param length
     * @param value
     * @return byte[]
     */
    public static byte[] byteArray1D(int length, byte value) {
        byte[] ret = new byte[length];
        for (int i = 0; i < length; i++) {
            ret[i] = value;
        }
        return ret;
    }

    /**
     * Easy byte array generation (note that these methods do not return
     * instance of CMatrix
     *
     * @param from
     * @param to
     * @param step
     * @return byte[]
     */
    public static byte[] byteArray1D(int from, int to, int step) {
        int length = (to - from) / step;
        byte[] ret = new byte[length];
        for (int i = 0; i < length; i++) {
            ret[i] = (byte) (from + i * step);
        }
        return ret;
    }

    /**
     * Easy short array generation (note that these methods do not return
     * instance of CMatrix
     *
     * @param length
     * @return short[]
     */
    public static short[] shortArray1D(int length) {
        short[] ret = new short[length];
        return ret;
    }

    /**
     * Easy short array generation (note that these methods do not return
     * instance of CMatrix
     *
     * @param length
     * @param value
     * @return short[]
     */
    public static short[] shortArray1D(int length, short value) {
        short[] ret = new short[length];
        for (int i = 0; i < length; i++) {
            ret[i] = value;
        }
        return ret;
    }

    /**
     * Easy short array generation (note that these methods do not return
     * instance of CMatrix
     *
     * @param from
     * @param to
     * @param step
     * @return short[]
     */
    public static short[] shortArray1D(short from, short to, short step) {
        int length = (to - from) / step;
        short[] ret = new short[length];
        for (int i = 0; i < length; i++) {
            ret[i] = (byte) (from + i * step);
        }
        return ret;
    }

    /**
     * calling conventions of static factory method pattern
     *
     * @return 1x1 CMatrix instance
     */
    public static CMatrix getInstance() {
        CMatrix cm = new CMatrix();
        return cm;
    }

    /**
     * calling conventions of static factory method pattern
     *
     * @return 1x1 CMatrix instance
     */
    public static CMatrix getInstance(NDArray d) {
        CMatrix cm = new CMatrix(d);
        return cm;
    }

    /**
     * calling conventions of static factory method pattern
     *
     * @return 1x1 CMatrix instance
     */
    public static CMatrix getInstance(ArrayList lst) {
        CMatrix cm = new CMatrix();
        cm = cm.fromArrayList(lst);
        return cm;
    }

    /**
     * calling conventions of static factory method pattern
     *
     * @return 1x1 CMatrix instance
     */
    public static CMatrix getInstance(List lst) {
        CMatrix cm = new CMatrix();
        cm = cm.fromList(lst);
        return cm;
    }

    /**
     * calling conventions of static factory method pattern
     *
     * @return 1x1 CMatrix instance
     */
    public static CMatrix getInstance(CMatrix c) {
        CMatrix cm = c;
        return cm;
    }

    /**
     * try to locate previous matrix if it exists
     *
     * @return previous Matrix
     */
//    public CMatrix prev() {
//        if (prevMatrix == null) {
//            return this;
//        }
//        prevMatrix.nextMatrix = this;
//        return prevMatrix;
//    }
    /**
     * try to locate n previous matrix if it exists
     *
     * @param n
     * @return previous Matrix
     */
//    public CMatrix prev(int n) {
//        for (int i = 0; i < n - 1; i++) {
//            prevMatrix = prevMatrix.prev();
//        }
//        return prevMatrix;
//    }
    /**
     * try to locate first cezeri matrix
     *
     * @return previous Matrix
     */
//    public CMatrix prevFirst() {
//        while (prevMatrix.prevMatrix != null) {
//            prevMatrix = prevMatrix.prev();
//        }
//        return prevMatrix;
//    }
    /**
     * try to locate next matrix if it exists
     *
     * @return next Matrix //
     */
//    public CMatrix next() {
//        if (nextMatrix == null) {
//            return this;
//        }
//        nextMatrix.prevMatrix = this;
//        return nextMatrix;
//    }
    /**
     * try to locate n next matrix if it exists
     *
     * @return next Matrix
     */
//    public CMatrix next(int n) {
//        for (int i = 0; i < n - 1; i++) {
//            nextMatrix = nextMatrix.next();
//        }
//        return nextMatrix;
//    }
    /**
     * try to locate last cezeri matrix
     *
     * @return previous Matrix
     */
//    public CMatrix nextLast() {
//        while (nextMatrix.nextMatrix != null) {
//            nextMatrix = nextMatrix.next();
//        }
//        return nextMatrix;
//    }
    /**
     * generate nxn zero matrix
     *
     * @param n
     * @return CMatrix
     */
    public static CMatrix getInstance(int n) {
        return new CMatrix(n);
    }

    /**
     * generate mxn zero matrix
     *
     * @param m : number of rows
     * @param n : number of columns
     * @return CMatrix
     */
    public static CMatrix getInstance(int m, int n) {
        return new CMatrix(m, n);
    }

    /**
     * generate nr x nc with float value matrix
     *
     * @param nr : number of rows
     * @param nc : number of columns
     * @param value : float initial value
     * @return CMatrix
     */
    public static CMatrix getInstance(int nr, int nc, float value) {
        return new CMatrix(nr, nc).addScalar(value);
    }

    /**
     * generate matrix of img size, and values corresponding
     *
     * @param img : BufferedImage
     * @return CMatrix
     */
    public static CMatrix getInstance(BufferedImage img) {
        if (img == null) {
            return new CMatrix();
        }
        return new CMatrix(img);
    }

    /**
     * generate nxn zero matrix
     *
     * @param n:float (number of rows and columns)
     * @return CMatrix
     */
    public static CMatrix getInstance(float n) {
        return new CMatrix((int) n);
    }

    /**
     * generate single row of matrix where number of colums equals to the length
     * of the array
     *
     * @param d: array of int
     * @return CMatrix float type
     */
    public static CMatrix getInstance(int... d) {
        return new CMatrix(d);
    }

    /**
     * generate single row of matrix where number of colums equals to the length
     * of the array
     *
     * @param d: array of int
     * @return CMatrix float type
     */
    public static CMatrix getInstance(long[] d) {
        return new CMatrix(d);
    }

    /**
     * generate single row of matrix where number of colums equals to the length
     * of the array
     *
     * @param d: array of int
     * @return CMatrix float type
     */
    public static CMatrix getInstance(byte[] d) {
        return new CMatrix(d);
    }

    /**
     * generate single row of matrix where number of colums equals to the length
     * of the array
     *
     * @param d: array of int
     * @return CMatrix float type
     */
    public static CMatrix getInstance(float... d) {
        return new CMatrix(d);
    }

    /**
     * generate single row of matrix where number of colums equals to the length
     * of the array
     *
     * @param d: array of int
     * @return CMatrix float type
     */
    public static CMatrix getInstance(double[] d) {
        return new CMatrix(d);
    }

    /**
     * generate a matrix that has d.length of rows and d[0].length of columns
     *
     * @param d: float array of int
     * @return CMatrix float type
     */
    public static CMatrix getInstance(int[][] d) {
        return new CMatrix(d);
    }

    /**
     * generate a matrix that has d.length of rows and d[0].length of columns
     *
     * @param d: float array of int
     * @return CMatrix float type
     */
    public static CMatrix getInstance(long[][] d) {
        return new CMatrix(d);
    }

    /**
     * generate a matrix that has d.length of rows and d[0].length of columns
     *
     * @param d: float array of int
     * @return CMatrix float type
     */
    public static CMatrix getInstance(byte[][] d) {
        return new CMatrix(d);
    }

    /**
     * generate a matrix that has d.length of rows and d[0].length of columns
     *
     * @param d: float array of int
     * @return CMatrix float type
     */
    public static CMatrix getInstance(float[][] d) {
        return new CMatrix(d);
    }

    /**
     * generate a matrix that has d.length of rows and d[0].length of columns
     *
     * @param d: float array of int
     * @return CMatrix float type
     */
    public static CMatrix getInstance(double[][] d) {
        return new CMatrix(d);
    }

    /**
     * generate a matrix from open cv mat object
     *
     * @return CMatrix float type
     */
    public static CMatrix getInstance(Mat m) {
        float[][] d = ImageProcess.imageToPixels2DFromOpenCV(m);
        return new CMatrix(d);
    }

    /**
     * generate a matrix from the text file choosen, assuming item separator is
     * ;
     *
     * @return CMatrix float type
     */
    public static CMatrix getInstanceFromFile() {
        float[][] d = FactoryUtils.readFromFile();
        return new CMatrix(d);
    }

    /**
     * generate a matrix from the text file choosen, assuming item separator is
     * token
     *
     * @return CMatrix float type
     */
    public static CMatrix getInstanceFromFile(String token) {
        float[][] d = FactoryUtils.readFromFile(token);
        return new CMatrix(d);
    }

    /**
     * generate a matrix from the text file chosen, assuming item separator is
     * token
     *
     * @return CMatrix float type
     */
    public static CMatrix getInstanceFromFile(String fileName, String token) {
        float[][] d = FactoryUtils.readFromFile(fileName, token);
        return new CMatrix(d);
    }

    public static CMatrix getInstancesFromARFF(Instances m) {
        return fromInstances(m);
    }

    /**
     * generate a matrix from instances of Weka format
     *
     * @param m : Weka instances
     * @return CMatrix float type
     */
    public static CMatrix fromInstances(Instances m) {
        float[][] ret = new float[m.numInstances()][m.numAttributes()];
        for (int i = 0; i < m.numInstances(); i++) {
            Instance ins = m.instance(i);
            ret[i] = FactoryUtils.toFloatArray1D(ins.toDoubleArray());
        }
        CMatrix cm = new CMatrix(ret);
        cm.wekaInstance = m;
        return cm;
    }

    /**
     * read Weka ARFF file format 2D data into CMatrix
     *
     * @param path : arff file path
     * @return
     */
    public static CMatrix getInstanceFromARFF(String path) {
        return fromARFF(path);
    }

    /**
     * read Excel sheet and transform data into CMatrix float[][] format
     *
     * @param path:excel file path
     * @return
     */
    public static CMatrix getInstanceFromExcelCSV(String path) {
        return new CMatrix(FactoryUtils.readCSV(path, ',', 0));
    }

    /**
     * read Excel sheet and transform data into CMatrix float[][] format
     *
     * @param path:excel file path
     * @return
     */
    public static CMatrix getInstanceFromExcelCSV(String path, char seperator, int headerline) {
        return new CMatrix(FactoryUtils.readCSV(path, seperator, headerline));
    }

    /**
     * generate a matrix from arff file format of Weka
     *
     * @param path : ARFF file path as String object
     * @return CMatrix float type
     */
    public static CMatrix fromARFF(String path) {
        try {
            Instances data = ConverterUtils.DataSource.read(path);
            data.setClassIndex(data.numAttributes() - 1);
            return CMatrix.fromInstances(data);
        } catch (Exception ex) {
            Logger.getLogger(CMatrix.class.getName()).log(Level.SEVERE, null, ex);
        }
        return CMatrix.getInstance();
    }

    /**
     * generate a matrix by reading arff file format of Weka
     *
     * @param path : ARFF file path as String object
     * @return CMatrix float type
     */
    public CMatrix readARFF(String path) {
        try {
            this.wekaInstance = ConverterUtils.DataSource.read(path);
            this.wekaInstance.setClassIndex(this.wekaInstance.numAttributes() - 1);
            return CMatrix.fromInstances(this.wekaInstance);
        } catch (Exception ex) {
            Logger.getLogger(CMatrix.class.getName()).log(Level.SEVERE, null, ex);
        }
        return CMatrix.getInstance();
    }

    /**
     * generate a matrix by reading csv file format and holds column names as
     * feature names and classLabels
     *
     * @param path : csv file path
     * @return CMatrix float type
     */
    public CMatrix readCSV(String path) {
        ReaderCSV csv = FactoryUtils.readFromCSVFile(path);
        array = Nd4j.create(FactoryUtils.toFloatArray2D(csv.data));
        columnNames = csv.columnNames;
        classLabels = csv.classLabels;
        image = ImageProcess.pixelsToImageGray(array.toFloatMatrix());
        return this;
    }

    public String[][] readArffAsStringArray(String path) {
        try {
            this.wekaInstance = ConverterUtils.DataSource.read(path);
        } catch (Exception ex) {
            Logger.getLogger(CMatrix.class.getName()).log(Level.SEVERE, null, ex);
        }
        this.wekaInstance.setClassIndex(this.wekaInstance.numAttributes() - 1);
        return FactoryUtils.readArffString(path, this.wekaInstance.numAttributes() - 1);
    }

    public String[][] readArffAsStringArray(String path, int classIndex) {
        return FactoryUtils.readArffString(path, classIndex);
    }

    /**
     * generate a matrix by loading the values read from image
     *
     * @param bf : BufferedImage
     * @return CMatrix
     */
    public CMatrix imload(BufferedImage bf) {
//        return new CMatrix(ImageProcess.imageToPixels255Int(GrayScale.luminosity(bf)));
        return new CMatrix(ImageProcess.imageToPixelsInt(bf));
    }

    /**
     * generate a matrix by loading the values read from image
     *
     * @param bf : BufferedImage
     * @return CMatrix
     */
    public CMatrix loadImage(BufferedImage bf) {
        return imload(bf);
    }

    /**
     * make a deep copy of the current matrix
     *
     * @return CMatrix
     */
    public CMatrix clone() {
        CMatrix ret = new CMatrix(array.dup());
        if (this.image != null) {
            ret.image = this.image;
        } else {
            //ret.image = ImageProcess.pixelsToImageGray(ret.array.toFloatMatrix());
        }
        ret.name = this.name;
        ret.hold_on = this.hold_on;
        ret.framePlot = this.framePlot;
        ret.wekaInstance = this.wekaInstance;
        return ret;
    }

    /**
     * make a deep copy of the given matrix
     *
     * @return CMatrix
     */
    public CMatrix clone(CMatrix cm) {
        CMatrix ret = new CMatrix(cm.array.dup());
        ret.name = cm.name;
        ret.hold_on = cm.hold_on;
        ret.framePlot = cm.framePlot;
        ret.wekaInstance = cm.wekaInstance;
        ret.columnNames = FactoryUtils.clone(this.columnNames);
        ret.classLabels = FactoryUtils.clone(this.classLabels);
        return ret;
    }

    private CMatrix() {
        this.array = Nd4j.zeros(1, 1);
        this.returnedValue = new CReturn();
    }

    private CMatrix(int n) {
        n = Math.abs(n);
        this.array = Nd4j.zeros(n, n);
        this.returnedValue = new CReturn();
    }

    private CMatrix(int nr, int nc) {
        nr = Math.abs(nr);
        nc = Math.abs(nc);
        this.array = Nd4j.zeros(nr, nc);
        this.returnedValue = new CReturn();
    }

    private CMatrix(int[][] d) {
        this.array = Nd4j.create(d);
        this.returnedValue = new CReturn();
    }

    private CMatrix(long[][] d) {
        this.array = Nd4j.create(d);
        this.returnedValue = new CReturn();
    }

    private CMatrix(byte[][] d) {
        this.array = Nd4j.create(FactoryUtils.toFloatArray2D(d));
        this.returnedValue = new CReturn();
    }

    private CMatrix(float[][] d) {
        this.array = Nd4j.create(d);
        this.returnedValue = new CReturn();
    }

    private CMatrix(INDArray d) {
        this.array = d;
        this.returnedValue = new CReturn();
    }

    private CMatrix(NDArray d) {
        this.array = d;
        this.returnedValue = new CReturn();
    }

    private CMatrix(double[][] d) {
        this.array = Nd4j.create(d);
        this.returnedValue = new CReturn();
    }

    private CMatrix(float[] d) {
        this.array = Nd4j.create(d, new int[]{d.length, 1});
        this.returnedValue = new CReturn();
    }

    private CMatrix(double[] d) {
        this.array = Nd4j.create(d, new int[]{d.length, 1});
        this.returnedValue = new CReturn();
    }

    private CMatrix(Object[] d) {
        float[][] m = new float[1][d.length];
        for (int i = 0; i < d.length; i++) {
            m[0][i] = Float.parseFloat(d[i] + "");
        }
        this.array = Nd4j.create(m);
        int[] sh = {(int) array.length(), 1};
        array = array.reshape(sh);
        this.returnedValue = new CReturn();
    }

    private CMatrix(int[] d) {
        float[] f = FactoryUtils.toFloatArray1D(d);
        this.array = Nd4j.create(f, new int[]{f.length, 1});
        this.returnedValue = new CReturn();
    }

    private CMatrix(long[] d) {
        float[] f = FactoryUtils.toFloatArray1D(d);
        this.array = Nd4j.create(f, new int[]{f.length, 1});
        this.returnedValue = new CReturn();
    }

    private CMatrix(byte[] d) {
        float[] f = FactoryUtils.toFloatArray1D(d);
        this.array = Nd4j.create(f, new int[]{f.length, 1});
        this.returnedValue = new CReturn();
    }

    private CMatrix(BufferedImage img) {
        this.image = img;
        this.array = Nd4j.create(ImageProcess.imageToPixelsFloat(img));
        this.returnedValue = new CReturn();
    }

    /**
     * get 1D float array which is identical to Matlab's a(:)
     *
     * @return float[]
     */
    public double[] toDoubleArray1D() {
        return array.ravel().toDoubleVector();
    }

    public double[][] toDoubleArray2D() {
        return array.toDoubleMatrix();
    }

    public float[] toFloatArray1D() {
        return array.ravel().toFloatVector();
    }

    public float[] flattenArray() {
        return array.ravel().toFloatVector();
    }

    public CMatrix flatten() {
        return new CMatrix(array.ravel().toFloatVector());
    }

    public float[][] toFloatArray2D() {
        return array.toFloatMatrix();
    }

    public int[] toIntArray1D() {
        return array.ravel().toIntVector();
    }

    public int[][] toIntArray2D() {
        return array.toIntMatrix();
    }

    public byte[] toByteArray1D() {
        return FactoryUtils.toByteArray1D(array.toFloatMatrix());
    }

    public byte[][] toByteArray2D() {
        return FactoryUtils.toByteArray2D(array.toFloatMatrix());
    }

    public short[] toShortArray1D() {
        return FactoryUtils.toShortArray1D(array.toFloatMatrix());
    }

    public short[][] toShortArray2D() {
        return FactoryUtils.toShortArray2D(array.toFloatMatrix());
    }

    public long[] toLongArray1D() {
        return FactoryUtils.toLongArray1D(array.toFloatMatrix());
    }

    public long[][] toLongArray2D() {
        return FactoryUtils.toLongArray2D(array.toFloatMatrix());
    }

    /**
     * return Alpha, Red, Green and Blue values of original RGB image first
     * dimension contains spectral information second dimension is image height
     * (number of rows) third dimension is image width (number of columns)
     *
     * @return
     */
    public float[][][] toFloatArray3D() {
        return ImageProcess.imageToPixelsColorDoubleFaster(image);
//        if (array.shape().length==3) {
//            return array.
//        }
    }

    public String[] toStringArray1D() {
        return FactoryUtils.toStringArray1D(this.array.toFloatMatrix());
    }

    public String[][] toStringArray2D() {
        return FactoryUtils.toStringArray2D(this.array.toFloatMatrix());
    }

    public String[][] toStringArray2DAsInt() {
        return FactoryMatrix.toStringArray2DAsInt(this.array.toFloatMatrix());
    }

    /**
     * set the array of current matrix note that clone is not calling so,
     * current matrix structure is changed
     *
     * @param a : float[]
     * @return CMatrix
     */
    public CMatrix setArray(float[] d) {
        this.array = Nd4j.create(d, new int[]{d.length, 1});
        return this;
    }

    /**
     * set the array of current matrix note that clone is not calling so,
     * current matrix structure is changed
     *
     * @param a : float[]
     * @return CMatrix
     */
    public CMatrix setArray(List<Float> lst) {
        double[] d = lst.stream().mapToDouble(i -> i).toArray();
        this.array = Nd4j.create(d, new int[]{d.length, 1});
        return this;
    }

    public CMatrix setArray(double[] d) {
        this.array = Nd4j.create(d, new int[]{d.length, 1});
        return this;
    }

    /**
     * set the array of current matrix note that clone is not calling so,
     * current matrix structure is changed
     *
     * @param a : float[]
     * @return CMatrix
     */
    public CMatrix setArray(float[] a, int nr, int nc) {
        float[][] d = new float[nr][nc];
        int k = 0;
        for (int i = 0; i < nr; i++) {
            for (int j = 0; j < nc; j++) {
                d[i][j] = a[k++];
            }
        }
        this.array = Nd4j.create(d);
        return this;
    }

    /**
     * set the array of current matrix note that clone is not calling anymore,
     * current matrix structure will be changed
     *
     * @param a : int[]
     * @return CMatrix
     */
    public CMatrix setArray(int[] dd) {
        float[] d = FactoryUtils.toFloatArray1D(dd);
        this.array = Nd4j.create(d, new int[]{d.length, 1});
//        int[] sh = {(int) array.length(), 1};
//        array = array.reshape(sh);
        return this;
    }

    /**
     * set the array of current matrix note that clone is not calling anymore,
     * current matrix structure will be changed
     *
     * @param a : int[][]
     * @return CMatrix
     */
    public CMatrix setArray(int[][] d) {
        this.array = Nd4j.create(d);;
        return this;
    }

    /**
     * set the array of current matrix note that clone is not calling anymore,
     * current matrix structure will be changed
     *
     * @param array : float[][]
     * @return CMatrix
     */
    public CMatrix setArray(float[][] d) {
        this.array = Nd4j.create(d);
        if (this.image != null) {
            if (this.image.getType() == 10) {
                this.image = ImageProcess.pixelsToImageGray(d);
            } else {
                this.image = ImageProcess.pixelsToImageColor(d);
            }
        }
        return this;
    }

    public CMatrix setArray(double[][] d) {
        this.array = Nd4j.create(d);
        return this;
    }

    public CMatrix setArray(INDArray d) {
        this.array = d;
        return this;
    }

    /**
     * set the array of current matrix note that clone is not calling anymore,
     * current matrix structure will be changed
     *
     * @param array : float[][][]
     * @return CMatrix
     */
    public CMatrix setArray(float[][][] array) {
        return fromARGB(array);
    }

    public CMatrix setValue(String p1, String p2, float val) {
        CMatrix ret = this.clone();
        float[][] d = FactoryMatrix.setValue(ret.getArray2Dfloat(), p1, p2, val);
        ret.setArray(d);
        return ret;
    }

    /**
     * Try to update the value of the matrix which is specified by 1D index
     * array note that this method can be used after calling the find method
     * which also produces the 1D column vector
     *
     *
     * @param indexes:results of find method or specific 1D index array that we
     * want to changed
     * @param val: value that we want to set it
     * @return updated CMatrix
     */
    public CMatrix setValue(int[] indexes, float val) {
        float[] d = array.toFloatVector();
        for (int i = 0; i < indexes.length; i++) {
            d[indexes[i]] = val;
        }
        setArray(d);
        return this;
    }

    /**
     * change the value of the matrix at specified row and column
     *
     * @param cp
     * @param val
     * @return
     */
    public CMatrix setValue(CPoint cp, float val) {
        array.putScalar(cp.toIndex(), val);
        return this;
    }

    /**
     * change the value of the matrix at specified row and column
     *
     * @param row
     * @param column
     * @param value
     * @return
     */
    public CMatrix setValue(int row, int column, float value) {
        array.putScalar(row, column, value);
        return this;
    }

    /**
     * fill the matrix with value
     *
     * @param value
     * @return
     */
    public CMatrix setValue(float value) {
        array.assign(value);
        return this;
    }

    /**
     * fill the matrix with value
     *
     * @param value
     * @return
     */
    public CMatrix setValue(double value) {
        array.assign(value);
        return this;
    }

    /**
     * fill the matrix with value
     *
     * @param value
     * @return
     */
    public CMatrix setValue(int value) {
        array.assign(value);
        return this;
    }

    /**
     * fill the matrix with value
     *
     * @param value
     * @return
     */
    public CMatrix setValue(long value) {
        array.assign(value);
        return this;
    }

    /**
     * Try to update the value of the matrix which is specified by 1D index
     * array Note that this method can be used after calling the find method
     * which also produces the 1D column vector
     *
     *
     * @param indexes:results of find method or specific 1D index array that we
     * want to changed
     * @param val: value that we want to set it
     * @return updated CMatrix
     */
    public CMatrix setValue(float[] indexes, float val) {
        float[] d = array.toFloatVector();
        for (int i = 0; i < indexes.length; i++) {
            d[(int) indexes[i]] = val;
        }
        setArray(d);
        //array = Nd4j.create(d);
        return this;
    }

    /**
     * column wised reshaping operation
     *
     * @param r
     * @param c
     * @return
     */
    public CMatrix reshape(int r, int c) {
        array = array.reshape(r, c);
        return this;
    }

    public CMatrix reshape(int... shape) {
        array = array.reshape(shape);
        return this;
    }

    public CPoint getRowColumn(int index) {
        CPoint p = new CPoint(0, 0);
        if (index < 0 || index > this.getRowNumber() * this.getColumnNumber()) {
            return p;
        } else {
            int col = index / this.getRowNumber();
            int row = index - col * this.getRowNumber();
            p.column = col;
            p.row = row;
        }
        return p;
    }

    public CPoint getRowColumn(float index) {
        CPoint p = new CPoint(0, 0);
        if (index < 0 || index > this.getRowNumber() * this.getColumnNumber()) {
            return p;
        } else {
            int col = (int) index / this.getRowNumber();
            int row = (int) index - col * this.getRowNumber();
            p.column = col;
            p.row = row;
        }
        return p;
    }

    public CMatrix range2D(float from_inclusive, float to_exclusive, int nrows) {
        array = Nd4j.create(FactoryMatrix.range2D(from_inclusive, to_exclusive, nrows));
        return this;
    }

    public CMatrix range2D(float from_inclusive, float to_exclusive, float step, int nrows) {
        array = Nd4j.create(FactoryMatrix.range2D(from_inclusive, to_exclusive, step, nrows));
        return this;
    }

    public CMatrix range(float to_exclusive) {
        array = Nd4j.arange(to_exclusive);
        int[] sh = {(int) array.length(), 1};
        array = array.reshape(sh);
        return this;
    }

    public CMatrix range(String cmd) {
        if (cmd.isEmpty()) {
            System.err.println("String param should contain : as \"3:10\"");
            return this;
        }
        String[] p = cmd.split(":");
        if (p.length == 1) {
            array = Nd4j.arange(Float.parseFloat(p[0]));
        } else if (p.length == 2) {
            float from_inclusive = Float.parseFloat(p[0]);
            float to_exclusive = Float.parseFloat(p[1]);
            array = Nd4j.arange(from_inclusive, to_exclusive);
        } else if (p.length == 3) {
            float from_inclusive = Float.parseFloat(p[0]);
            float to_exclusive = Float.parseFloat(p[1]);
            float step = Float.parseFloat(p[2]);
            array = Nd4j.arange(from_inclusive, to_exclusive, step);
        }
        int[] sh = {(int) array.length(), 1};
        array = array.reshape(sh);
        return this;
    }

    public CMatrix range(float from_inclusive, float to_exclusive) {
        array = Nd4j.arange(from_inclusive, to_exclusive);
        int[] sh = {(int) array.length(), 1};
        array = array.reshape(sh);
        return this;
    }

    public CMatrix range(float from_inclusive, float to_exclusive, float step) {
        array = Nd4j.arange(from_inclusive, to_exclusive, step);
        int[] sh = {(int) array.length(), 1};
        array = array.reshape(sh);
        return this;
    }

    public CMatrix range(float from_inclusive, float to_exclusive, int ncols) {
        array = Nd4j.linspace((long) from_inclusive, (long) to_exclusive, ncols);
        return this;
    }

    public CMatrix range(float from_inclusive, float to_exclusive, float step, int ncols) {
        array = Nd4j.create(FactoryMatrix.range(from_inclusive, to_exclusive, step, ncols));
        return this;
    }

    public CMatrix range(int[] p) {
        array = Nd4j.create(p);
        int[] sh = {(int) array.length(), 1};
        array = array.reshape(sh);
        return this;
    }

    public CMatrix range(float[] p) {
        array = Nd4j.create(p);
        int[] sh = {(int) array.length(), 1};
        array = array.reshape(sh);
        return this;
    }

//    public CMatrix vector(float from, float to) {
//        return range(from, to);
//    }
//
//    public CMatrix vector(float from, float step, float to) {
//        return range(from, to, step);
//    }
//
    public CMatrix linspace(float from, float to, int n) {
        float step = (to - from) / n;
        return range(from, to, step);
    }

    public CMatrix linspace(float from, float to, float step) {
        return range(from, to, step);
    }

//    public CMatrix vector2D(float from, float to, int nrows) {
//        return range2D(from, to, nrows);
//    }
    public CMatrix imgradient(int from, int to, int nrows) {
        return range2D(from, to, nrows);
    }

    /**
     * Build nxn identity matrix with value of val
     *
     * @param n
     * @return
     */
    public CMatrix eye(int n, float val) {
        array = Nd4j.eye(n).mul(val);
        return this;
    }

    /**
     * Build nxn identity matrix
     *
     * @param n
     * @return
     */
    public CMatrix eye(int n) {
        array = Nd4j.eye(n);
        return this;
    }

    public CMatrix zeros(int n) {
        array = Nd4j.zeros(n, n);
        return this;
    }

    /**
     * generate a nr x nc-size matrix with a fixed value of val
     *
     * @param nr : number of rows
     * @param nc : number of columns
     * @param val: value
     * @return : CMatrix
     */
    public CMatrix numbers(int nr, int nc, int val) {
        array = Nd4j.ones(nr, nc).mul(val);
        return this;
    }

    /**
     * generate a nr x nc-size matrix with a fixed value of val
     *
     * @param nr : number of rows
     * @param nc : number of columns
     * @param val: value
     * @return : CMatrix
     */
    public CMatrix values(int nr, int nc, int val) {
        array = Nd4j.ones(nr, nc).muli(val);
        return this;
    }

    /**
     * generate a nr x nc-size matrix with a fixed value of val
     *
     * @param nr : number of rows
     * @param nc : number of columns
     * @param val: value
     * @return : CMatrix
     */
    public CMatrix values(int nr, int nc, float val) {
        array = Nd4j.ones(nr, nc).muli(val);
        return this;
    }

    /**
     * generate a nr x nc-size matrix with a fixed value of val
     *
     * @param nr : number of rows
     * @param nc : number of columns
     * @param val: value
     * @return : CMatrix
     */
    public CMatrix values(int nr, int nc, double val) {
        array = Nd4j.ones(nr, nc).muli(val);
        return this;
    }

    public CMatrix zeros(int nr, int nc) {
        array = Nd4j.zeros(nr, nc);
        return this;
    }

    public CMatrix ones(int n) {
        array = Nd4j.ones(n, n);
        return this;
    }

    public CMatrix ones(int nr, int nc) {
        array = Nd4j.ones(nr, nc);
        return this;
    }

    public CMatrix rand() {
        array = Nd4j.rand(1, 1);
        return this;
    }

    public CMatrix randWithSeed(int seed) {
        array = Nd4j.rand(seed, array.shape());
        return this;
    }

    public CMatrix rand(int n) {
        array = Nd4j.rand(n, n);
        return this;
    }

    public CMatrix randWithSeed(int n, int seed) {
        array = Nd4j.rand(seed, new long[]{n, n});
        return this;
    }

    public CMatrix rand(int nr, int nc) {
        array = Nd4j.rand(nr, nc);
        return this;
    }

    public CMatrix randWithSeed(int nr, int nc, int seed) {
        array = Nd4j.rand(seed, new long[]{nr, nc});
        return this;
    }

    public CMatrix rand(int nr, int nc, float max) {
        array = Nd4j.rand(nr, nc).mul(max);
        return this;
    }

    public CMatrix randWithSeed(int nr, int nc, float max, int seed) {
        array = Nd4j.rand(seed, new long[]{nr, nc}).mul(max);
        return this;
    }

    /**
     * randTimeSeries method generates random signal similar to the timeline
     * series of trends in any assets which provides us to inspect time series
     * signals in 1D
     *
     * @param r
     * @param c
     * @param min
     * @param max
     * @return
     */
    public CMatrix randTimeSeries(int nr, int nc, float min, float max) {
        float[][] f = new float[nr][nc];
        array = Nd4j.create(FactoryMatrix.fillRandMatrixTimeSeries(f, min, max, random));
        return this;
    }

    public CMatrix rand(int nr, int nc, float min, float max) {
        array = Nd4j.rand(nr, nc).mul(max - min).add(min);
        return this;
    }

    public CMatrix randWithSeed(int nr, int nc, float min, float max, int seed) {
        array = Nd4j.rand(seed, new long[]{nr, nc}).mul(max - min).add(min);
        return this;
    }

    public CMatrix randn() {
        array = Nd4j.randn(1, 1);
        return this;
    }

    /**
     * Generates nxn square matrix with normal distribution
     *
     * @param n
     * @return
     */
    public CMatrix randn(int n) {
        array = Nd4j.randn(n, n);
        return this;
    }

    /**
     * Generates rxc matrix with normal distribution
     *
     * @param r
     * @param c
     * @return
     */
    public CMatrix randn(int nr, int nc) {
        array = Nd4j.randn(nr, nc);
        return this;
    }

    /**
     * Generates rxc matrix with normal distribution within max upper bound
     *
     * @param r
     * @param c
     * @param max
     * @return
     */
    public CMatrix randn(int nr, int nc, float max) {
        array = Nd4j.randn(nr, nc).mul(max);
        return this;
    }

    /**
     * Generates rxc matrix with normal distribution within [min...max] bounds
     *
     * @param r
     * @param c
     * @param min
     * @param max
     * @return
     */
    public CMatrix randn(int nr, int nc, float min, float max) {
        array = Nd4j.randn(nr, nc).mul(max - min).add(min);
        return this;
    }

    /**
     * With a given mean and variance generates rxc matrix with normal
     * distribution return variance*x+mean
     *
     * @param r
     * @param c
     * @param mean
     * @param var
     * @return
     */
    public CMatrix randnMeanVariance(int nr, int nc, float mean, float var) {
        float[][] f = new float[nr][nc];
        array = Nd4j.create(FactoryMatrix.fillRandNormalMatrixMeanVar(f, mean, var, random));
        return this;
    }

    /**
     * Plot scatter graph of the first two column vectors of the CMatrix Another
     * usage is an overloaded scatter method which takes two vector as an input
     * parameter or two CMatrix objects.
     *
     * @return CMatrix
     */
    public CMatrix scatter() {
        FrameScatterPlot frm = new FrameScatterPlot(this);
        frm.setVisible(true);
        return this;
    }

    /**
     * Plot blob scatter graph of the first two column vectors of the CMatrix.
     * Another usage is an overloaded scatter method which takes two vector as
     * an input parameter or two CMatrix objects.
     *
     * @return CMatrix
     */
    public CMatrix scatterBlob() {
        FrameScatterBlob frm = new FrameScatterBlob(this);
        frm.setVisible(true);
        return this;
    }

    /**
     * Plot blob scatter graph of the first two column vectors of the CMatrix.
     * Another usage is an overloaded scatter method which takes two vector as
     * an input parameter or two CMatrix objects.
     *
     * @return CMatrix
     */
    public CMatrix scatterBlob(TFigureAttribute attr) {
        FrameScatterBlob frm = new FrameScatterBlob(this, attr);
        frm.setVisible(true);
        return this;
    }

    /**
     * Plot blob scatter graph of the first two column vectors of the CMatrix.
     * Another usage is an overloaded scatter method which takes two vector as
     * an input parameter or two CMatrix objects.
     *
     * @return CMatrix
     */
    public CMatrix scatterBlob(String columns, TFigureAttribute attr) {
        CMatrix ret = this.clone();
        ret = ret.cmd(":", columns).cat(1, ret.cmd(":", "-1"));
        FrameScatterBlob frm = new FrameScatterBlob(ret, attr);
        frm.setVisible(true);
        return ret;
    }

    /**
     * Plot scatter graph of two vector (float[] array) as an input parameter.
     *
     * Notification: two vectors should be the same size
     *
     * @return CMatrix
     */
    public CMatrix scatter(float[] x, float[] y) {
        if (x.length != y.length) {
            System.err.println("Array dimension mismatched.");
        }
        int n = Math.min(x.length, y.length);
        float[][] d = FactoryMatrix.catHorizontalMatrix(x, y);
        FrameScatterPlot frm = new FrameScatterPlot(CMatrix.getInstance(d));
        frm.setVisible(true);
        return this;
    }

    /**
     * used as Matlab scatter function with figure attribute values
     *
     * @param attr : figure attribute values
     * @return CMatrix
     */
    public CMatrix scatter(TFigureAttribute attr) {
        FrameScatterPlot frm = new FrameScatterPlot(this, attr);
        frm.setVisible(true);
        return this;
    }

    /**
     * Matlab compatible command: plot the curves of each column in the matrix
     *
     * @return CMatrix
     */
    public CMatrix plot() {
        this.array = Nd4j.create(FactoryUtils.RemoveNaNToZero(array.toFloatMatrix()));
        if (!hold_on) {
            framePlot = new FramePlot(this);
        } else {
            if (framePlot == null) {
                framePlot = new FramePlot(this);
            }
            framePlot.setMatrix(this);
        }
        TFigureAttribute fg = new TFigureAttribute();
        fg.pointType = plotType;
        framePlot.setFigureAttribute(fg);
        framePlot.setVisible(true);
        return this;
    }

    /**
     * Matlab compatible command: plot the curves of each column in the matrix
     *
     * @return CMatrix
     */
    public CMatrix ploty() {
        this.array = Nd4j.create(FactoryUtils.RemoveNaNToZero(array.toFloatMatrix()));
        if (!hold_on) {
            framePloty = new FramePloty(this);
        } else {
            if (framePloty == null) {
                framePloty = new FramePloty(this);
            }
            framePloty.setMatrix(this);
        }
        TFigureAttribute fg = new TFigureAttribute();
        fg.pointType = plotType;
        framePloty.setFigureAttribute(fg);
        framePloty.setVisible(true);
        return this;
    }

    /**
     * plot the curves of each column in the matrix
     *
     * @return CMatrix
     */
    public CMatrix plotRefresh(FramePlot frm) {
        frm.setMatrix(this);
        frm.setVisible(true);
        return this;
    }

    /**
     * By using single plot frame, this command try to redraw updated matrix it
     * is useful if you make animation or moving simulation within the loop
     *
     * @return CMatrix
     */
    public CMatrix plotRefresh() {
        if (framePlot == null) {
            framePlot = new FramePlot(this);
            framePlot.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        }
        framePlot.setMatrix(this);
        framePlot.setVisible(true);
        return this;
    }

    /**
     * By using single plot frame, this command try to redraw updated matrix it
     * is useful if you make animation or moving simulation within the loop
     *
     * @return CMatrix
     */
    public CMatrix plotRefresh(TFigureAttribute fg) {
        if (framePlot == null) {
            framePlot = new FramePlot(this);
            framePlot.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        }
        framePlot.setMatrix(this);
        framePlot.setFigureAttribute(fg);
        framePlot.setVisible(true);
        return this;
    }

    public CMatrix plotRefresh(TFigureAttribute fg, String caption) {
        if (framePlot == null) {
            framePlot = new FramePlot(this);
            framePlot.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        }
        framePlot.setMatrix(this);
        framePlot.setFigureAttribute(fg);
        framePlot.setVisible(true);
        framePlot.setTitle(caption);
        return this;
    }

    /**
     * By using single plot frame, this command try to redraw updated matrix it
     * is useful if you make animation or moving simulation within the loop
     *
     * @return CMatrix
     */
    public CMatrix plotRefresh(float[] x) {
        if (framePlot == null) {
            framePlot = new FramePlot(this);
            framePlot.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        }
        framePlot.setMatrix(this);
        framePlot.setVisible(true);
        return this;
    }

    /**
     * By using single plot frame, this command try to redraw updated matrix it
     * is useful if you make animation or moving simulation within the loop
     *
     * @return CMatrix
     */
    public CMatrix plotOn() {
        if (framePlot == null) {
            framePlot = new FramePlot(this);
            framePlot.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        }
        framePlot.setMatrix(this);
        framePlot.setVisible(true);
        return this;
    }

    /**
     * plot the curves of each column in the matrix
     *
     * @return CMatrix
     */
    public CMatrix bar() {
        FrameBar frm = new FrameBar(this);
        frm.setVisible(true);
        return this;
    }

    /**
     * plot the curves based on provided x axis values
     *
     * @param x:value of x axis
     * @return
     */
    public CMatrix plot(float[] x) {
        FramePlot frm = new FramePlot(this.clone(), x);
        frm.setVisible(true);
        return this;
    }

    public CMatrix plot(TFigureAttribute attr) {
        FramePlot frm = new FramePlot(this.clone(), attr);
        frm.setVisible(true);
        return this;
    }

    public CMatrix plot(TFigureAttribute attr, float[] x) {
        FramePlot frm = new FramePlot(this.clone(), attr, x);
        frm.setVisible(true);
        return this;
    }

    public CMatrix setPlotType(String pointType) {
        this.plotType = pointType;
        return this;
    }

    public CMatrix plot(String title) {
        FramePlot frm = new FramePlot(this.clone());
        frm.setPlotType(this.plotType);
        frm.setVisible(true);
        frm.setTitle(title);
        return this;
    }

    /**
     * Matlab compatible command: show image in the frame
     *
     *
     * Matlabdakine benzer ÅŸekilde temel resim gÃ¶steren figure aÃ§ar default
     * olarak imgenin orjinali nasÄ±lsa onu gÃ¶sterir gri ise gri rgb ise rgb
     * deÄŸiÅŸiklik yapmaz. EÄŸer gri gÃ¶strmek istiyorsanÄ±z imshowGray komutunu,
     * diÄŸer taraftan renkli gÃ¶stermek iÃ§in de imshowRGB yi kullanÄ±nÄ±z.
     *
     * @return
     */
    public CMatrix imshow() {
        if (image == null || image.getType() == BufferedImage.TYPE_BYTE_GRAY) {
            image = ImageProcess.pixelsToImageGray(array.toFloatMatrix());
        }
        FrameImage frm = new FrameImage(this, this.imagePath, this.imagePath);
        frm.setVisible(true);
        return this;
    }

    /**
     * Matlab compatible command: show image in the frame
     *
     *
     * Matlabdakine benzer ÅŸekilde temel resim gÃ¶steren figure aÃ§ar default
     * olarak imgenin orjinali nasÄ±lsa onu gÃ¶sterir gri ise gri rgb ise rgb
     * deÄŸiÅŸiklik yapmaz. EÄŸer gri gÃ¶strmek istiyorsanÄ±z imshowGray komutunu,
     * diÄŸer taraftan renkli gÃ¶stermek iÃ§in de imshowRGB yi kullanÄ±nÄ±z.
     *
     * @return
     */
    public CMatrix imshow(boolean isUpdate) {
        if (image == null || isUpdate) {
            image = ImageProcess.pixelsToImageGray(array.toFloatMatrix());
        }
        FrameImage frm = new FrameImage(this, this.imagePath, "none");
        frm.setVisible(true);
        return this;
    }

    /**
     * transpose array first and then apply transpose process to image
     *
     * @return
     */
    public CMatrix imTranspose() {
        if (image == null) {
            image = ImageProcess.pixelsToImageGray(array.toFloatMatrix());
        } else {
            array = array.transpose();
            image = ImageProcess.pixelsToImageGray(array.toFloatMatrix());
        }
        return this;
    }

    /**
     *
     * show on single frame for each call only one frame is maintained
     *
     * @param title:caption of the frame
     * @return
     */
    public CMatrix imshowRefresh(String title) {
        if (image == null) {
            if (array.maxNumber().floatValue() > 0.0f) {
                image = ImageProcess.pixelsToImageGray(array.toFloatMatrix());
            } else {
                image = ImageProcess.pixelsToImageColor(array.toFloatMatrix());
            }
        }
//        if (image.getType() == BufferedImage.TYPE_BYTE_GRAY) {
//            image = ImageProcess.pixelsToImageGray(array.toFloatMatrix());
//        } else if (image.getType() != BufferedImage.TYPE_BYTE_GRAY) {
//            image = ImageProcess.pixelsToImageColor(array.toFloatMatrix());
//        }
        if (frameImage == null) {
            frameImage = new FrameImage();
            frameImage.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        }
        frameImage.setImage(image, this.imagePath, title);
        frameImage.setTitle(title);
        frameImage.setVisible(true);
        return this;
    }

    /**
     *
     * show on single frame for each call only one frame is maintained
     *
     * @return
     */
    public CMatrix imshowRefresh() {
        return imshowRefresh("");
    }

    /**
     *
     * show on single frame for each call only one frame is maintained
     *
     * @return
     */
    public CMatrix imRefresh() {
        if (image == null || image.getType() == BufferedImage.TYPE_BYTE_GRAY) {
            image = ImageProcess.pixelsToImageGray(array.toFloatMatrix());
        }
        return this;
    }

    /**
     * Traditional imshow reopens a new Figure foreach call. If we want to
     * utilize single Frame we should pass object as a parameter to the
     * overloaded imshow method
     *
     * @param frm
     * @return
     */
    public CMatrix imshow(FrameImage frm) {
//        image = ImageProcess.pixelsToBufferedImageGray(array);
        frm.setImage(image, imagePath, "none");
        frm.setVisible(true);
        return this;
    }

//    /**
//     * Traditional imshow reopens a new Figure foreach call. If we want to
//     * utilize single Frame we should pass object as a parameter to the
//     * overloaded imshow method
//     *
//     * @param frm
//     * @return
//     */
//    public CMatrix imshow(FrameImage frm, boolean force) {
//        if (force) {
//            
//        }
//        image = ImageProcess.pixelsToBufferedImage255(array);
//        frm.setImage(image);
//        frm.setVisible(true);
//        return this;
//    }
    /**
     * Traditional imshow reopens a new Figure foreach call. If we want to
     * utilize single Frame we should pass object as a parameter to the
     * overloaded imshow method
     *
     * @param frm
     * @return
     */
    public CMatrix imshow(FrameImage frm, String title) {
        if (image == null || image.getType() == BufferedImage.TYPE_BYTE_GRAY) {
            image = ImageProcess.pixelsToImageGray(array.toFloatMatrix());
        }
        frm.setImage(image, imagePath, title);
        frm.setVisible(true);
        return this;
    }

    /**
     * opens a figure and show the image on that figure refresh tries to build
     * image from the matrix
     *
     * @return
     */
//    public CMatrix imshow(boolean refresh) {
//        imshowRGB(refresh);
//        return this;
//    }
    /**
     * opens the figure with image
     *
     * @param title: caption of the figure
     * @return
     */
    public CMatrix imshow(String title) {
//        if (image == null || image.getType() == BufferedImage.TYPE_BYTE_GRAY) {
//            image = ImageProcess.pixelsToImageGray(array);
//        }
        if (image == null) {
            image = ImageProcess.pixelsToImageGray(array.toFloatMatrix());
        }
        FrameImage frm = new FrameImage(this, imagePath, title);
        frm.setVisible(true);
        return this;
    }

    /**
     * DetaylÄ± ve geliÅŸmiÅŸ resim gÃ¶steren figure aÃ§ar
     *
     * @return
     */
//    public CMatrix imshowAdvanced() {
//        if (image == null || image.getType() == BufferedImage.TYPE_BYTE_GRAY) {
//            image = ImageProcess.pixelsToBufferedImage255(array);
//        }
//        FrameImageAdvanced frm = new FrameImageAdvanced(image, imagePath);
//        frm.setVisible(true);
//        return this;
//    }
    /**
     * DetaylÄ± ve geliÅŸmiÅŸ resim gÃ¶steren figure aÃ§ar
     *
     * @return
     */
//    public CMatrix imshowAdvanced(String title) {
//        if (image == null || image.getType() == BufferedImage.TYPE_BYTE<_GRAY) {
//            image = ImageProcess.pixelsToBufferedImage255(array);
//        }
//        FrameImageAdvanced frm = new FrameImageAdvanced(image, title);
//        frm.setVisible(true);
//        return this;
//    }
//    public CMatrix imshowGray() {
////        if (image == null) {
////            image = ImageProcess.pixelsToBufferedImage255(FactoryUtils.toIntArray(array));
////        }
//        image = ImageProcess.pixelsToBufferedImage255(array);
////        FrameImage frm = new FrameImage(ImageProcess.pixelsToBufferedImage255(ImageProcess.imageToPixels255(image)), this.imagePath);
//        FrameImage frm = new FrameImage(image, this.imagePath);
//        frm.setVisible(true);
//        return this;
//    }
    public CMatrix toGrayLevel() {
        CMatrix ret = this.clone();
        if (ret.image != null) {
            ret.image = ImageProcess.toGrayLevel(ret.image);
            ret.array = Nd4j.create(ImageProcess.bufferedImageToArray2D(ret.image));
        } else {
            ret.array = Nd4j.create(ImageProcess.bufferedImageToArray2D(ret.image));
            ret.image = ImageProcess.pixelsToImageGray(ret.array.toFloatMatrix());
        }
        return ret;
    }

    /**
     * convert RGB color image to the Gray Value. This method is MATLAB
     * compatible
     *
     * @return
     */
    public CMatrix rgb2gray() {
        return toGrayLevel();
    }

    /**
     * convert RGB color image to the Hue Saturation and Value (Note that Value
     * is sometimes called as Brightness value therefore naming HSV as HSB is
     * also correct convention) this methos is MATLAB compatible
     *
     * @return
     */
    public CMatrix rgb2hsv() {
        CMatrix ret = this.clone();

        ret.image = ImageProcess.rgb2hsv(ret.image);
        return ret;
    }

    public CMatrix hsv2rgb() {
        CMatrix ret = this.clone();

        ret.image = ImageProcess.hsv2rgb(ret.image);
        return ret;
    }

//    public CMatrix toHSV() {
//        CMatrix ret = this.clone(); lastCM=ret; 
//        ret.image = ImageProcess.toHSVColorSpace(ret.image);
//        return ret;
//    }
    public CMatrix getHueChannel() {
        CMatrix ret = this.clone();

        ret.image = ImageProcess.getHueChannel(ret.image);
        ret.array = Nd4j.create(ImageProcess.imageToPixelsFloat(ret.image));
        return ret;
    }

    public CMatrix getSaturationChannel() {
        CMatrix ret = this.clone();

        ret.image = ImageProcess.getSaturationChannel(ret.image);
        ret.array = Nd4j.create(ImageProcess.imageToPixelsFloat(ret.image));
        return ret;
    }

    public CMatrix getValueChannel() {
        CMatrix ret = this.clone();

        ret.image = ImageProcess.getValueChannel(ret.image);
        ret.array = Nd4j.create(ImageProcess.imageToPixelsFloat(ret.image));
        return ret;
    }

    /**
     * Matlabdakine benzer ÅŸekilde temel resim gÃ¶steren figure aÃ§ar
     *
     * @return
     */
    public CMatrix showImage() {
        return CMatrix.this.imshow();
    }

    /**
     * Matlabdakine benzer ÅŸekilde temel resim gÃ¶steren figure aÃ§ar
     *
     * @return
     */
    public CMatrix showImage(String title) {
        return CMatrix.this.imshow(title);
    }

    /**
     * Matlab compatible command: show image histogram
     *
     * is used for only images. For any other matrix you should use hist instead
     *
     * @return original CMatrix
     */
    public CMatrix imhist() {
        return imhist("");
    }

    public CMatrix imhist(String title) {
        CMatrix ret = this.clone();

        if (ret.image == null || ret.image.getType() == BufferedImage.TYPE_BYTE_GRAY) {
            ret.image = ImageProcess.pixelsToImageGray(array.toFloatMatrix());
        }
        CMatrix cc = ImageProcess.getHistogram(ret);
        FrameImageHistogram frm = new FrameImageHistogram(cc);
        frm.setTitle(title);
        frm.setVisible(true);
        return this;
    }

    public CMatrix ocv_imhist(String title) {
        CMatrix ret = this.clone();

        if (ret.image == null || ret.image.getType() == BufferedImage.TYPE_BYTE_GRAY) {
            ret.image = ImageProcess.pixelsToImageGray(array.toFloatMatrix());
        }
        ret.image = ImageProcess.ocv_hist(ret.image);
        CMatrix cc = CMatrix.getInstance(ret.image);
        FrameImageHistogram frm = new FrameImageHistogram(cc);
        frm.setTitle(title);
        frm.setVisible(true);
        return this;
    }

    /**
     * is used for revert or invert the image color
     *
     * @return
     */
    public CMatrix imcomplement() {
        CMatrix ret = this.clone();

        ret = ret.rgb2gray();
        BufferedImage bf = ImageProcess.revert(ret.image);
        ret.setImage(bf);
        return ret;
    }

    /**
     * is used for revert or invert the image color
     *
     * @return
     */
    public CMatrix imnegative() {
        return imcomplement();
    }

    /**
     * hist by default calculates 256 bin for a given column matrix
     *
     * @return histogram of each column
     */
    public CMatrix hist() {
        float[] d = FactoryMatrix.getHistogram(array.toFloatMatrix(), 256);
        //setArray(d).transpose();
        array = Nd4j.create(d, new int[]{d.length, 1});
        this.bar();
        return this;
    }

    /**
     * Matlab compatible code: calculate the histogram of the matrix for a
     * specified number of bins as column wised
     *
     * @return histogram of each column
     */
    public CMatrix hist(int nBins) {
        if (getRowNumber() == 1 && getColumnNumber() == 1) {
            return this;
        } else if (getRowNumber() == 1 && getColumnNumber() > 1) {
            array = array.transpose();
        }
        float[] d = FactoryMatrix.getHistogram(array.toFloatMatrix(), nBins);
        setArray(d);
//        FrameImageHistogram frm = new FrameImageHistogram(this);
//        frm.setTitle("");
//        frm.setVisible(true);
        return this;
    }

    /**
     * calculate the histogram of the matrix for a specified number of bins as
     * column wised
     *
     * @return histogram of each column
     */
    public CMatrix hist(int nBins, String title) {
        float[] d = FactoryMatrix.getHistogram(array.toFloatMatrix(), nBins);
        array = Nd4j.create(d, new int[]{d.length, 1});
        FrameHistogram frm = new FrameHistogram(this.clone(), this, title);
        frm.setVisible(true);
        return this;
    }

    /**
     * calculate the histogram of the matrix for a specified number of bins as
     * column wised
     *
     * @return histogram of each column
     */
    public CMatrix hist(int nBins, String title, boolean isStatisticsVisible) {
        float[] d = FactoryMatrix.getHistogram(array.toFloatMatrix(), nBins);
        array = Nd4j.create(d, new int[]{d.length, 1});
        FrameHistogram frm = new FrameHistogram(this.clone(), this, title, isStatisticsVisible);
        frm.setVisible(true);
        return this;
    }

    public CMatrix getImageHistogramData() {
        return ImageProcess.getHistogram(this);
    }

    public CMatrix getHistogramData() {
        float[] d = FactoryMatrix.getHistogram(array.toFloatMatrix(), 256);
        array = Nd4j.create(d, new int[]{d.length, 1});
        return this;
    }

    public CMatrix getHistogramData(int nBins) {
        float[] d = FactoryMatrix.getHistogram(array.toFloatMatrix(), nBins);
        array = Nd4j.create(d, new int[]{d.length, 1});
        return this;
    }

    public CMatrix showHistogram() {
        return imhist();
    }

    /**
     * Probability Density Function (image histogram normalize to 0..1)
     *
     * @return
     */
    public CMatrix pdf() {
        return getPDFData();
    }

    /**
     * Cumulative Density Function
     *
     * @return
     */
    public CMatrix cdf() {
        return getCDFData();
    }

    public CMatrix getPDFData() {
        CMatrix m_hist = ImageProcess.getHistogram(toGrayLevel());
        float sum = m_hist.sumTotal();
        m_hist = m_hist.divideScalar(sum).clone(m_hist);
        return m_hist.transpose();
    }

    public CMatrix getCDFData() {
        float[] h_pdf = FactoryUtils.toFloatArray1D(getPDFData().array.toIntVector());
        float[] h_cdf = new float[h_pdf.length];
        float t = 0;
        for (int i = 0; i < h_pdf.length; i++) {
            t += h_pdf[i];
            h_cdf[i] = t;
        }
        setArray(h_cdf);
        return this;
    }

    public CMatrix showPDF() {
        this.pdf().plot();
        return this;
    }

    public CMatrix showCDF() {
        this.cdf().plot();
        return this;
    }

    public CMatrix imhistRed() {
        FrameImageHistogram frm = new FrameImageHistogram(ImageProcess.getHistogramRed(this));
        frm.setVisible(true);
        return this;
    }

    public CMatrix imhistGreen() {
        FrameImageHistogram frm = new FrameImageHistogram(ImageProcess.getHistogramGreen(this));
        frm.setVisible(true);
        return this;
    }

    public CMatrix imhistBlue() {
        FrameImageHistogram frm = new FrameImageHistogram(ImageProcess.getHistogramBlue(this));
        frm.setVisible(true);
        return this;
    }

    public CMatrix imhistGray() {
        return imhist();
    }

    public CMatrix imhistRed(String title) {
        FrameImageHistogram frm = new FrameImageHistogram(ImageProcess.getHistogramRed(this));
        frm.setTitle(title);
        frm.setVisible(true);
        return this;
    }

    public CMatrix imhistGreen(String title) {
        FrameImageHistogram frm = new FrameImageHistogram(ImageProcess.getHistogramGreen(this));
        frm.setTitle(title);
        frm.setVisible(true);
        return this;
    }

    public CMatrix imhistBlue(String title) {
        FrameImageHistogram frm = new FrameImageHistogram(ImageProcess.getHistogramBlue(this));
        frm.setTitle(title);
        frm.setVisible(true);
        return this;
    }

    public CMatrix imhistGray(String title) {
        return imhist(title);
    }

    public CMatrix imhistAlpha() {
        FrameImageHistogram frm = new FrameImageHistogram(ImageProcess.getHistogramAlpha(this));
        frm.setVisible(true);
        return this;
    }

    public CMatrix showHistogramRed() {
        return imhistRed();
    }

    public CMatrix showHistogramGreen() {
        return imhistGreen();
    }

    public CMatrix showHistogramBlue() {
        return imhistBlue();
    }

    public CMatrix showHistogramGray() {
        return imhistGray();
    }

    public CMatrix showHistogramAlpha() {
        return imhistAlpha();
    }

    public CMatrix showDataGrid() {
        FrameDataGrid frm = new FrameDataGrid(this);
        frm.setVisible(true);
        return this;
    }

    public CMatrix formatFloat(int n) {
        setArray(FactoryUtils.formatFloat(array.toFloatMatrix(), n));
        return this;
    }

    public CMatrix fillMatrix(float val) {
        array = Nd4j.ones(getRowNumber(), getColumnNumber()).mul(val);
        return this;
    }

    public CMatrix merge(CMatrix m2, String type) {
        //alt alta eklemek iÃ§in ";" kullanÄ±lÄ±r
        if (type.equals(";")) {
            array = Nd4j.vstack(array, m2.array);
        }
        //yan yana eklemek iÃ§in "," kullanÄ±lÄ±r
        if (type.equals(",")) {
            array = Nd4j.hstack(array, m2.array);
        }
        return this;
    }

    public CMatrix vstack(CMatrix m2) {
        array = Nd4j.vstack(array, m2.array);
        return this;
    }

    public CMatrix hstack(CMatrix m2) {
        array = Nd4j.hstack(array, m2.array);
        return this;
    }

    public CMatrix transpose() {
        array = array.transpose();
        return this;
    }

    public CMatrix subMatrix(CMatrix m, Point p1, Point p2) {
        int r = m.getRowNumber();
        int c = m.getColumnNumber();
        float[][] f = m.toFloatArray2D();
        CMatrix ret = m;
        if (p1.x < 0 || p1.y < 0 || p1.x > p2.x || p1.y > p2.y || p1.x > r || p1.y > c || p2.x > r || p2.y > c) {
            return null;
        } else {
            float[][] d = new float[p2.x - p1.x][p2.y - p1.y];
            for (int i = p1.x; i < p2.x; i++) {
                for (int j = p1.y; j < p2.y; j++) {
                    d[i - p1.x][j - p1.y] = f[i][j];
                }
            }
            ret.setArray(d);
            ret.name = this.name + "|submatrix";
            return ret;
        }
    }

    public CMatrix subMatrix(Point p1, Point p2) {
        CMatrix ret = this.clone();
        int r = ret.getRowNumber();
        int c = ret.getColumnNumber();
        float[][] f = ret.getArray2Dfloat();
        if (p1.x < 0 || p1.y < 0 || p1.x > p2.x || p1.y > p2.y || p1.x > r || p1.y > c || p2.x > r || p2.y > c) {
            return null;
        } else {
            float[][] d = new float[p2.y - p1.y][p2.x - p1.x];
            for (int i = p1.x; i < p2.x; i++) {
                for (int j = p1.y; j < p2.y; j++) {
                    d[j - p1.y][i - p1.x] = f[j][i];
                }
            }
            ret.setArray(d);
            ret.name = this.name + "|submatrix";
            return ret;
        }
    }

    public CMatrix subMatrix(CPoint p1, CPoint p2) {
        CMatrix ret = this.clone();
        int r = ret.getColumnNumber();
        int c = ret.getRowNumber();
        float[][] f = ret.getArray2Dfloat();
        if (p1.column < 0 || p1.row < 0 || p1.column > p2.column || p1.row > p2.row || p1.column > r || p1.row > c || p2.column > r || p2.row > c) {
            return null;
        } else {
            float[][] d = new float[p2.row - p1.row][p2.column - p1.column];
            for (int i = p1.column; i < p2.column; i++) {
                for (int j = p1.row; j < p2.row; j++) {
                    d[j - p1.row][i - p1.column] = f[j][i];
                }
            }
            ret.setArray(d);
            ret.name = this.name + "|submatrix";
            return ret;
        }
    }

    public CMatrix subMatrix(Rectangle rect) {
        Point p1 = new Point(rect.x, rect.y);
        Point p2 = new Point(rect.x + rect.width, rect.y + rect.height);
        return subMatrix(p1, p2);
    }

    public CMatrix dotProduct(CMatrix cm) {
        INDArray arr = Transforms.dot(array, cm.array);
        if (arr.isScalar()) {
            array = Nd4j.zeros(1, 1);
            array.assign(arr);
            System.out.println("burasÄ±:" + array.rank());
        }
        return this;
    }

    public CMatrix dotProduct(CMatrix cm1, CMatrix cm2) {
        INDArray arr = Transforms.dot(cm1.array, cm2.array);
        if (arr.isScalar()) {
            array = Nd4j.zeros(1, 1);
            array.assign(arr);
            System.out.println("burasÄ±:" + array.isScalar());
        }
        return this;
    }

//    /**
//     * Biiznillah Matlab de herhangi bir matrisin iÃ§eriÄŸini mesela
//     * a=b([1,4,11]); ÅŸeklinde alabiliyorduk burada aynÄ± iÅŸlem yapÄ±lmaya
//     * Ã§alÄ±ÅŸÄ±lmÄ±ÅŸtÄ±r. 1 parametre girilse row lardan ilgili index teki verileri
//     * filtreler 2 paramatre girilirse hem row hem column filtresi yapar.
//     *
//     * dynamic parameter
//     *
//     * @param p
//     * @return
//     */
//    public CMatrix matrix(int[] p) {
//        float[] ret = new float[1];
//        if (p.length == 0) {
//            return null;
//        } else if (p.length > 0) {
//            int[] rows = p;
//            ret = new float[rows.length];
//            float[] one_d = FactoryUtils.toFloatArray1D(this.array);
//            for (int i = 0; i < rows.length; i++) {
//                try {
//                    ret[i] = one_d[rows[i]];
//                } catch (Exception e) {
//                    e.printStackTrace();
//                }
//
//            }
//        } else {
////            int[] rows = p[0];
////            int[] cols = p[1];
////            d = new float[rows.length][this.getColumnNumber()];
////            for (int i = 0; i < rows.length; i++) {
////                d[i] = this.array[rows[i]];
////            }
////            d = new CMatrix(d).transpose().array;
////            float[][] d2 = new float[cols.length][d[0].length];
////            for (int i = 0; i < cols.length; i++) {
////                d2[i] = d[cols[i]];
////            }
////            d = new CMatrix(d2).transpose().array;
//        }
//        CMatrix ret_matrix = new CMatrix(ret);
//        ret_matrix.name = this.name + "|submatrix";
//        return ret_matrix;
//    }
//    public CMatrix row(CMatrix prev, int[] rows) {
//        float[][] d;
//        d = new float[rows.length][this.getColumnNumber()];
//        for (int i = 0; i < rows.length; i++) {
//            d[i] = this.array[rows[i]];
//        }
//        CMatrix ret = this.clone();
//
//        ret.array = d;
//        ret.name = this.name + "|row";
//        ret.prevMatrix = prev;
//        return ret;
//    }
//
//    public CMatrix column(CMatrix prev, int[] cols) {
//        float[][] yedek = new CMatrix(prev.array).transpose().array;
//        float[][] d = new float[cols.length][yedek[0].length];
//        for (int i = 0; i < cols.length; i++) {
//            d[i] = yedek[cols[i]];
//        }
//        d = new CMatrix(d).transpose().array;
//        CMatrix ret = new CMatrix(d);
//        ret.name = this.name + "|column";
//        ret.prevMatrix = prev;
//        return ret;
//    }
//    /**
//     * converts 2D Matrix to 1D matrix by executing : command
//     *
//     * @return CMatrix
//     */
//    public CMatrix matrix(String p) {
//        CMatrix ret = this.clone();
//
//        if (p.equals(":")) {
//            ret = new CMatrix(FactoryUtils.toFloatArray1D(ret.array));
//        }
//        ret.image = null;
//        return ret;
//    }
    /**
     * Tries to interpret String parameter as Matlab vectorization commands like
     * that interpret([1,3,5],[3,7]) means get subset based on the specified
     * criteria
     *
     * @param p
     * @return
     */
    public CMatrix cmd(int[] p) {
        int nr = p.length;
        INDArray t = array.slice(p[0]);
        for (int i = 1; i < nr; i++) {
            t = Nd4j.concat(1, t, array.slice(p[i]));
        }
        setArray(t);
        return this;
    }
//
//    /**
//     * Tries to interpret String parameter as Matlab vectorization commands like
//     * that interpret(":") means get subset based on the specified criteria
//     *
//     * @param p
//     * @return
//     */
//    public CMatrix cmd(String p) {
//        return matrix(p);
//    }

    /**
     * Tries to interpret String parameter as Matlab or Python slicing
     * operations for example cmd("1:3,5:-1","-3:")
     *
     * @param p1 :
     * @param p2 :
     * @return
     */
    public CMatrix cmd(String p1, String p2) {
        setArray(FactoryMatrix.cmd(array.toFloatMatrix(), p1, p2));
        return this;
    }

    /**
     * B.Matlabdeki randperm in aynÄ±sÄ± GÃ¶revi kendisine verilen n sayÄ±sÄ±na kadar
     * random indexler Ã¼retmek
     *
     * @param n
     * @return
     */
    public CMatrix randPerm(int n) {
        float[] m = new float[n];
        ArrayList<Float> v = new ArrayList<Float>();
        for (int i = 0; i < n; i++) {
            v.add(new Float(i));
        }
        for (int i = 0; i < n; i++) {
            int a = new Random().nextInt(n - i);
            m[i] = v.get(a);
            v.remove(a);
        }
        CMatrix ret = new CMatrix(m);
        //return ret.clone(this);
        return ret;
    }

    /**
     * B.Matlabdeki randperm in aynÄ±sÄ± GÃ¶revi kendisine verilen n sayÄ±sÄ±na kadar
     * random indexler Ã¼retmek
     *
     * @return
     */
    public CMatrix randPerm(int from, int to) {
        int n = to - from;
        float[] m = new float[n];
        ArrayList<Float> v = new ArrayList<Float>();
        for (int i = from; i < to; i++) {
            v.add(new Float(i));
        }
        for (int i = 0; i < n; i++) {
            int a = new Random().nextInt(n - i);
            m[i] = v.get(a);
            v.remove(a);
        }
        CMatrix ret = new CMatrix(m);
        //return ret.clone(this);
        return ret;
    }

    public int[] randPermInt(int n) {
        int[] m = new int[n];
        ArrayList<Integer> v = new ArrayList<Integer>();
        for (int i = 0; i < n; i++) {
            v.add(new Integer(i));
        }
        for (int i = 0; i < n; i++) {
            int a = new Random().nextInt(n - i);
            m[i] = v.get(a);
            v.remove(a);
        }
        return m;
    }

    /**
     * similar to the numpy permute command change the tensors of the multiple
     * dimensional array note that for two dims permute will produce as
     * transpose MxN -> NxM
     *
     * @param d
     * @return
     */
    public CMatrix permute(float[][] d) {
        CMatrix cm = CMatrix.getInstance(d).transpose();
        return cm;
    }

    /**
     * similar to the numpy permute command for three dimensional array change
     * the tensors of the multiple dimensional array
     *
     * @return
     */
    public CMatrix permute(NDArray d, int... shape) {
        d = (NDArray) d.permute(shape);
        return new CMatrix(d);
    }

    /**
     * similar to the numpy permute command for three dimensional array change
     * the tensors of the multiple dimensional array
     *
     * @return
     */
    public CMatrix permute(int... shape) {
        NDArray d = (NDArray) this.array;
        return permute(d, shape);
    }

    /**
     * calculate the randomly selected permutations of n elements
     *
     * @param n
     * @return
     */
    public CMatrix randPermute(int n) {
        return randPerm(n);
    }

    public CMatrix randPermute(int from, int to) {
        return randPerm(from, to);
    }

    public CMatrix minusScalar(float n) {
        array = array.sub(n);
        return this;
    }

    /**
     * n-CMatrix
     *
     * @param n
     * @return
     */
    public CMatrix minusFromScalar(float n) {
        array = array.mul(-1).add(n);
        return this;
    }

    public CMatrix addScalar(float n) {
        array = array.add(n);
        return this;
    }

    public CMatrix addScalar(double n) {
        array = array.add(n);
        return this;
    }

    public CMatrix addScalar(int n) {
        array = array.add(n);
        return this;
    }

    public CMatrix addScalar(long n) {
        array = array.add(n);
        return this;
    }

    public CMatrix plusScalar(float n) {
        array = array.add(n);
        return this;
    }

    public CMatrix exp() {
        array = Transforms.exp(array);
        return this;
    }

    public CMatrix exp(float n) {
        array = Transforms.exp(array);
        return this;
    }

    public CMatrix log() {
        array = Transforms.log(array);
        return this;
    }

    public CMatrix logPlusScalar(float n) {
        array = Transforms.log(array).add(n);
        return this;
    }

    public CMatrix log10() {
        array = Transforms.log(array, 10);
        return this;
    }

    public CMatrix pow(float n) {
        array = Transforms.pow(array, n, false);
        return this;
    }

    public CMatrix sin() {
        array = Transforms.sin(array);
        return this;
    }

    public CMatrix asin() {
        array = Transforms.asin(array);
        return this;
    }

    /**
     * sinc(x) is a partial function normalized with pi which is defined as |1,
     * t=0 sinc(x) =| |sin(pi*x)/(pi*x) t != 0
     *
     *
     * @return
     */
    public CMatrix sinc() {
        float[][] f = array.toFloatMatrix();
        int nr = f.length;
        int nc = f[0].length;
        for (int i = 0; i < nr; i++) {
            for (int j = 0; j < nc; j++) {
                if (f[i][j] != 0) {
                    array.putScalar(new int[]{i, j}, (float) (Math.sin(Math.PI * f[i][j]) / (Math.PI * f[i][j])));
                } else {
                    array.putScalar(new int[]{i, j}, 1);
                }
            }
        }
        return this;
    }

    public CMatrix cos() {
        array = Transforms.cos(array);
        return this;
    }

    public CMatrix acos() {
        array = Transforms.acos(array);
        return this;
    }

    public CMatrix tan() {
        array = Transforms.tan(array);
        return this;
    }

    public CMatrix cot() {
        array = Transforms.cos(array.dup()).div(Transforms.sin(array.dup()));
        return this;
    }

    public CMatrix acot() {
        array = Transforms.atan(array);
        return this;
    }

    public CMatrix atan() {
        array = Transforms.atan(array);
        return this;
    }

    public CMatrix tanh() {
        array = Transforms.atanh(array);
        return this;
    }

    public CMatrix sigmoid() {
        array = Transforms.sigmoid(array);
        return this;
    }

    public CMatrix sigmoid(float beta) {
        setArray(FactoryMatrix.sigmoid(array.toFloatMatrix(), beta));
        return this;
    }

    public CMatrix sigmoid(float alpha, float beta) {
        setArray(FactoryMatrix.sigmoid(array.toFloatMatrix(), alpha, beta));
        return this;
    }

    public CMatrix abs() {
        array = Transforms.abs(array);
        return this;
    }

    /**
     * Calculate square root of each element (element wised operation)
     *
     * @return CMatrix
     */
    public CMatrix sqrt() {
        array = Transforms.sqrt(array);
        return this;
    }

    public CMatrix round() {
        array = Transforms.round(array);
        return this;
    }

    /**
     * format float values with provided precision
     *
     * @param precision
     * @return
     */
    public CMatrix round(int precision) {
        setArray(FactoryUtils.formatFloat(array.toFloatMatrix(), precision));
        return this;
    }

    public CMatrix toDegrees() {
        array = array.mul(180).div(Math.PI);
        return this;
    }

    public CMatrix toRadians() {
        array = array.mul(Math.PI).div(180);
        return this;
    }

    public TMatrixCell max() {
        INDArray nd = Nd4j.argMax(array);
        int n = nd.toIntVector()[0];
        int pr = n / getColumnNumber();
        int pc = n - pr * getColumnNumber();
        TMatrixCell mc = new TMatrixCell();
        mc.index = n;
        mc.value = array.getFloat(n);
        mc.p = new CPoint(pr, pc);
        return mc;
    }

    public TMatrixCell min() {
        INDArray nd = Nd4j.argMin(array);
        int n = nd.toIntVector()[0];
        int pr = n / getColumnNumber();
        int pc = n - pr * getColumnNumber();
        TMatrixCell mc = new TMatrixCell();
        mc.index = n;
        mc.value = array.getFloat(n);
        mc.p = new CPoint(pr, pc);
        return mc;
    }

    public float sumTotal() {
        return array.sumNumber().floatValue();
    }

    public float prodTotal() {
        return array.prodNumber().floatValue();
    }

    public float meanTotal() {
        float m = this.sumTotal() / array.length();
        return m;
    }

    /**
     * equals to meanTotal()
     *
     * @return
     */
    public float getMean() {
        float m = this.sumTotal() / array.length();
        return m;
    }

    public float stdTotal() {
        return array.stdNumber().floatValue();
    }

    /**
     * equals to stdTotal()
     *
     * @return
     */
    public float getStd() {
        return array.stdNumber().floatValue();
    }

    /**
     * Sutun bazlÄ± toplama iÅŸlemi yapar mxn matrisinin tÃ¼m elemanlarÄ±nÄ± toplamak
     * istiyorsanÄ±z sumTotal veya iki defa sum Ã§aÄŸÄ±rÄ±nÄ±z
     *
     * @return CMatrix
     */
    public CMatrix sum() {
        array = array.sum(0);
        long size = array.size(0);
        array = array.reshape(new int[]{1, (int) size});
        return this;
    }

    /**
     * Sutun bazlÄ± iÅŸlem yapar sum fonksiyonundan farklÄ± olarak sonuÃ§ matrisin
     * shape'i orjinal matris ile aynÄ±dÄ±r. Cumulative distribution gibi
     * davranÄ±r.
     *
     * @return CMatrix
     */
    public CMatrix sumConsecutive() {
        float[][] d = FactoryUtils.sumConsecutive(getArray2Dfloat());
        setArray(d);
        return this;
    }

    /**
     * Sutun bazlÄ± Ã§arpma iÅŸlemi yapar mxn matrisinin tÃ¼m elemanlarÄ±nÄ± Ã§arpmak
     * istiyorsanÄ±z prodTotal veya iki defa prod Ã§aÄŸÄ±rÄ±nÄ±z
     *
     * @return CMatrix
     */
    public CMatrix prod() {
        array = array.prod(0);
        return this;
    }

    /**
     * Sutun bazlÄ± iÅŸlem yapar prod fonksiyonundan farklÄ± olarak sonuÃ§ matrisin
     * shape'i orjinal matris ile aynÄ±dÄ±r. factorial gibi davranÄ±r (her bir
     * eleman iÃ§in).
     *
     * @return CMatrix
     */
    public CMatrix prodConsecutive() {
        float[][] d = FactoryUtils.prodConsecutive(getArray2Dfloat());
        setArray(d);
        return this;
    }

    public CMatrix mean() {
        array = array.mean(0);
        return this;
    }

    public CMatrix std() {
        array = array.std(0);
        return this;
    }

    public CMatrix var() {
        array = array.var(0);
        return this;
    }

    public CMatrix divideScalar(float n) {
        array = array.div(n);
        return this;
    }

    public CMatrix divideByScalar(float n) {
        array = array.rdiv(n);
        return this;
    }

    public CMatrix dot(CMatrix cm) {
        CMatrix ret = this.clone();
        ret.array = ret.array.mmul(cm.array);
        return ret;
    }

    public CMatrix doti(CMatrix cm) {
        CMatrix ret = this.clone();
        ret.array = ret.array.mmuli(cm.array);
        return ret;
    }

    public CMatrix mmul(CMatrix cm) {
        return dot(cm);
    }

    public CMatrix mmuli(CMatrix cm) {
        return doti(cm);
    }

    public CMatrix mul(CMatrix cm) {
        CMatrix ret = this.clone();
        ret.array = ret.array.mul(cm.array);
        return ret;
    }

    public CMatrix muli(CMatrix cm) {
        CMatrix ret = this.clone();
        ret.array = ret.array.muli(cm.array);
        return ret;
    }

    /**
     * get the index of maximum value of the matrix
     *
     * @return float
     */
    public float argMax() {
        INDArray d = Nd4j.argMax(array);
        return d.getFloat(0);
    }

    /**
     * get the indexes of maximum values along dim if dim=0 means column-wised
     * if dim=1 means row-wised
     *
     * @param dim : either 0 (column) or 1 (row)
     * @return float[]
     */
    public float[] argMax(int dim) {
        INDArray d = Nd4j.argMax(array, dim);
        return d.toFloatVector();
    }

    /**
     * get the indexes of maximum values along dim if dim=0 means column-wised
     * if dim=1 means row-wised
     *
     * @param dim : either 0 (column) or 1 (row)
     * @return float[]
     */
    public float argMin() {
        INDArray d = Nd4j.argMin(array);
        return d.getFloat(0);
    }

    /**
     * get the index of minimum value of the matrix
     *
     * @return float
     */
    public float[] argMin(int dim) {
        INDArray d = Nd4j.argMin(array, dim);
        return d.toFloatVector();
    }

    public CMatrix getMagnitude() {
        setArray(FactoryMatrix.getMagnitude(array.toFloatMatrix()));
        return this;
    }

    public CMatrix getMagnitude(CMatrix cm) {
        cm.setArray(FactoryMatrix.getMagnitude(cm.array.toFloatMatrix()));
        return cm;
    }

    public CMatrix getAngle(CMatrix second) {
        return calculateCosineTheoremWithDotProduct(second);
    }

    public CMatrix calculateCosineTheoremWithDotProduct(CMatrix second) {
        float[][] d = new float[1][1];
        d[0][0] = (float) (Math.acos(dot(second).getValue() / (getMagnitude().getValue() * second.getMagnitude().getValue())) / Math.PI * 180);
        setArray(d);
        return this;
    }

    public CMatrix dot(CMatrix cm, Dimension dm) {
        if (!this.isIdentical(this, cm)) {
            System.out.println("Matrixes should be identical in size");
            return this;
        }
        setArray(array.mul(cm.array));
        return this;
    }

    public CMatrix timesScalar(float n) {
        array = array.muli(n);
        return this;
    }

    public CMatrix timesScalar(double n) {
        array = array.muli(n);
        return this;
    }

    public CMatrix timesScalar(int n) {
        array = array.muli(n);
        return this;
    }

    public CMatrix timesScalar(long n) {
        array = array.muli(n);
        return this;
    }

//    public CMatrix dot(CMatrix cm) {
//        return multiplyElement(cm);
//    }
    /**
     * Matlab compatible command: element wise multiplication
     *
     * @param cm : second matrix
     *
     * @return CMatrix
     */
    public CMatrix times(CMatrix cm) {
        if (this.getColumnNumber() != cm.getRowNumber()) {
            throw new InputMismatchException("can not multiply these two matrices please make sure both matrices obey the matrix multiplication rule i.e. column number of first matrix must equal to the colum number of the second matrix");
//            return this;
        }
        array = array.mul(cm.array);
        return this;
    }

    public CMatrix multiplyScalar(float n) {
        return timesScalar(n);
    }

    public CMatrix multiplyScalar(double n) {
        return timesScalar(n);
    }

    public CMatrix multiplyScalar(int n) {
        return timesScalar(n);
    }

    public CMatrix multiplyScalar(long n) {
        return timesScalar(n);
    }

    public CMatrix mul(float n) {
        return timesScalar(n);
    }

    public CMatrix scale(float n) {
        return timesScalar(n);
    }

    public String toString(String var) {
        String s = var + "=\n";
        s += "Matrix of [" + this.getRowNumber() + "x" + this.getColumnNumber() + "]=\n";
        float[][] f = this.array.toFloatMatrix();
        for (int i = 0; i < this.getRowNumber(); i++) {
            String r = "";
            for (int j = 0; j < this.getColumnNumber(); j++) {
                r += f[i][j] + "\t";
            }
            s += r + "\n";
        }
        return s;
    }

    public String toStringWithToken(String token) {
        String s = "";
        float[][] f = this.array.toFloatMatrix();
        for (int i = 0; i < this.getRowNumber(); i++) {
            String r = "";
            for (int j = 0; j < this.getColumnNumber(); j++) {
                r += f[i][j] + token;
            }
            s += r;
        }
        s = s.substring(0, s.length() - 1);
        return s;
    }

    public String toStringFull() {
        String ret = "Matrix of " + this.array.shapeInfoToString() + "\n" + this.array.toStringFull();
        return ret;
    }

    @Override
    public String toString() {
        String ret = "Matrix of " + this.array.shapeInfoToString() + "\n" + this.array.toString();
        return ret;
        /*
        if (this.array.isScalar()) {
            String s = "Matrix of [1x1" + "]=\n";
            s += this.array;
            return s;
        } else {
            String s = "Matrix of [" + this.getRowNumber() + "x" + this.getColumnNumber() + "]=\n";
            float[][] f = this.array.toFloatMatrix();
            for (int i = 0; i < this.getRowNumber(); i++) {
                String r = "";
                for (int j = 0; j < this.getColumnNumber(); j++) {
                    r += f[i][j] + "\t";
                }
                s += r + "\n";
            }
            return s;
        }
         */
    }

    public String toCommaString() {
        String s = "";
        float[][] f = this.array.toFloatMatrix();
        for (int i = 0; i < this.getRowNumber(); i++) {
            String r = "";
            for (int j = 0; j < this.getColumnNumber(); j++) {
                r += (f[i][j] + "").replace(".", ",") + "\t";
            }
            if (i < this.getRowNumber() - 1) {
                s += r + "\n";
            } else {
                s += r;
            }
        }
        return s;
    }

    public String toCSVString() {
        String s = "";
        float[][] f = this.array.toFloatMatrix();
        for (int i = 0; i < this.getRowNumber(); i++) {
            String r = "";
            for (int j = 0; j < this.getColumnNumber(); j++) {
                r += f[i][j] + ";";
            }
            s += r + "\n";
        }
        return s;
    }

    public String toCommaStringWithIdentifier() {
        String s = "Matrix of [" + this.getRowNumber() + "x" + this.getColumnNumber() + "]=\n";
        float[][] f = this.array.toFloatMatrix();
        for (int i = 0; i < this.getRowNumber(); i++) {
            String r = "";
            for (int j = 0; j < this.getColumnNumber(); j++) {
                r += (f[i][j] + "").replace(".", ",") + "\t";
            }
            s += r + "\n";
        }
//        System.out.println(s);
        return s;
    }

    public CMatrix printlnComma() {
        System.out.println(this.toCommaString());
        return this;
    }

    public CMatrix printlnComma(String s) {
        System.out.println(s + "\n" + this.toCommaString());
        return this;
    }

    /**
     * print each element of CMatrix float[][] data as a Matrix Form
     *
     * @return CMatrix
     */
    public CMatrix println() {
        System.out.println(this.toString());
        return this;
    }

    /**
     * print each element of CMatrix whole
     *
     * @return CMatrix
     */
    public CMatrix printlnFull() {
        System.out.println(this.toStringFull());
        return this;
    }

    /**
     * print top 5 rows of CMatrix float[][] data with column names if available
     *
     * @return CMatrix
     */
    public CMatrix head() {
        float[][] f = this.array.toFloatMatrix();
        int nr = f.length;
        int nc = f[0].length;
        System.out.println("Matrix of [" + nr + "x" + nc + "]");
        int max = 5;
        if (this.getRowNumber() < max) {
            max = this.getRowNumber();
        }
        if (columnNames != null && !columnNames.isEmpty()) {
            for (String columnName : columnNames) {
                System.out.print(columnName + "\t");
            }
            System.out.println("");
        }
        if (classLabels != null && !classLabels.isEmpty()) {
            for (int i = 0; i < max; i++) {
                for (int j = 0; j < nc; j++) {
                    System.out.print(FactoryUtils.formatDouble(f[i][j]) + "\t");
                }
                System.out.println(classLabels.get(i));
            }
        } else {
            for (int i = 0; i < max; i++) {
                for (int j = 0; j < nc; j++) {
                    System.out.print(f[i][j] + "\t");

                }
                System.out.println("");
            }
        }
        return this;
    }

    public CMatrix println(String s) {
        System.out.println(toString(s));
        return this;
    }

    /**
     * print the content of the matrix
     *
     * @return
     */
    public CMatrix dump() {
        System.out.println(this.toString());
        return this;
    }

    /**
     * print the content of the matrix by adding extra info on the head
     *
     * @param s
     * @return
     */
    public CMatrix dump(String s) {
        System.out.println(toString(s));
        return this;
    }

    public CMatrix fprintln(String file) {
        FactoryUtils.writeToFile(file, this.toString());
        return this;
    }

    public CMatrix fprintln() {
        FactoryUtils.writeToFile(this.toString());
        return this;
    }

    public CMatrix toNewFile() {
        FactoryUtils.writeToFile(this.toString());
        return this;
    }

    public CMatrix toAppendFile() {
        FactoryUtils.writeOnFile(this.toString());
        return this;
    }

    public CMatrix toNewFileCSV(String file) {
        FactoryUtils.writeToFile(file, this.toCSVString());
        return this;
    }

    public CMatrix toNewFile(String file) {
        FactoryUtils.writeToFile(file, this.toCSVString());
        return this;
    }

    public CMatrix writeToNewFileCSV(String file) {
        toNewFileCSV(file);
        return this;
    }

    public CMatrix writeToNewFile(String file) {
        toNewFile(file);
        return this;
    }

    public CMatrix saveNewFileAsCSV(String file) {
        toNewFileCSV(file);
        return this;
    }

    public CMatrix saveOnFileAsCSV(String file) {
        FactoryUtils.writeOnFile(file, this.toCSVString());
        return this;
    }

    public CMatrix writeOnFile(String file) {
        toAppendFile(file);
        return this;
    }

    public CMatrix saveOnFile(String file) {
        toAppendFile(file);
        return this;
    }

    public CMatrix saveToFile(String file) {
        toNewFile(file);
        return this;
    }

    public CMatrix saveImage(String file_name) {
        if (image == null) {
            image = ImageProcess.pixelsToImageGray(array.toFloatMatrix());
        }
        ImageProcess.saveImage(image, file_name);
        return this;
    }

    public CMatrix saveImage(String path, String file_name) {
        if (image == null) {
            image = ImageProcess.pixelsToImageGray(array.toFloatMatrix());
        }
        ImageProcess.saveImage(image, path + "/" + file_name);
        return this;
    }

    public CMatrix saveImage() {
        if (image == null) {
            image = ImageProcess.pixelsToImageGray(array.toFloatMatrix());
        }
        ImageProcess.saveImage(image);
        return this;
    }

    public CMatrix saveImageAtFolder(String folderPath) {
        if (image == null) {
            image = ImageProcess.pixelsToImageGray(array.toFloatMatrix());
        }
        ImageProcess.saveImageAtFolder(image, folderPath);
        return this;
    }

    /**
     *
     * @param file_path
     * @param learning_type :TLearningType.REGRESSION or
     * TLearningType.CLASSIFICATION
     * @return
     */
    public CMatrix toWekaArff(String file_path, int learning_type) {
        FactoryUtils.writeToArffFile(file_path, array.toFloatMatrix(), learning_type);
        return this;
    }

    /**
     *
     * @param file_path
     * @param learning_type :TLearningType.REGRESSION or
     * TLearningType.CLASSIFICATION
     * @return
     */
    public CMatrix toARFF(String file_path, int learning_type) {
        FactoryUtils.writeToArffFile(file_path, array.toFloatMatrix(), learning_type);
        return this;
    }

    /**
     *
     * @param file_path
     * @param learning_type :TLearningType.REGRESSION or
     * TLearningType.CLASSIFICATION
     * @return
     */
    public CMatrix writeAsArffFile(String file_path, int learning_type) {
        FactoryUtils.writeToArffFile(file_path, array.toFloatMatrix(), learning_type);
        return this;
    }

    public CMatrix toAppendFile(String file) {
        FactoryUtils.writeOnFile(file, this.toString());
        return this;
    }

    /**
     * B. Matlab deki find komutuna banzer Ã§alÄ±ÅŸmaktadÄ±r. find her zaman 1
     * sÃ¼tÃ¼nlu n satÄ±rlÄ± sÃ¼tÃ¼n matrisi geri dÃ¶nderir iÃ§erik olarak ta sadece
     * index bilgisini tutar
     *
     * @param op TMatrixOperator enum tipindeki sÄ±nÄ±fÄ± call eder.
     * @param d taranacak base matris
     * @param x matrisin elemanlarÄ± neye eÅŸitse
     * @return
     *
     */
    public CMatrix findIndex(TMatrixOperator op, CMatrix d, float x) {
        return op.apply(d, x);
    }

    /**
     * operates as Matlab's find method try to find 1D indexes of the matrix
     * based on the specified matrix operator logical conditions returns cloned
     * matrix indeed found indexes are provided in int[] d parameter object
     *
     * @param op:logical criteria
     * @param x :Target value or matching constant number
     * @return
     */
    public CMatrix findIndex(TMatrixOperator op, float x) {
        CMatrix ret = this.clone();
        ret = op.apply(ret, x);
        return ret;
    }

    /**
     * operates as Matlab's find method try to find 1D indexes of the matrix
     * based on the specified matrix operator logical conditions returns cloned
     * matrix indeed found indexes are provided in int[] d parameter object
     *
     * @param op:logical criteria
     * @param x :Target value or matching constant number
     * @return
     */
    public CMatrix findItemsByIndex(int... p) {
        return getMatrixValueByIndex(p);
    }

    /**
     * Find metodu istenilen bir karÅŸÄ±laÅŸtÄ±rma iÅŸlemi ve karÅŸÄ±laÅŸtÄ±rmada
     * kullanÄ±lacak x deÄŸerini matlab matris ifadeleri ile belirli bir sÃ¼tun
     * veya sub-matrix Ã¼zerinde iÅŸleyerek bulduÄŸu row larÄ±n satÄ±r numaralarÄ±nÄ±
     * 1D vektÃ¶r olarak geri dÃ¶nderir. KullanÄ±cÄ± eÄŸer isterse bu vektÃ¶rÃ¼ yani
     * cmatrix nesnesini cmd komutuna parametre olarak gÃ¶nderip deÄŸerleri bir
     * sutun dizisi olarak alabilir.
     *
     *
     * operates as Matlab's find method try to find 1D indexes of the matrix
     * based on the specified matrix operator logical conditions returns cloned
     * matrix indeed found indexes are provided in int[] d parameter object
     *
     * @param op:logical criteria
     * @param x :Target value or matching constant number
     * @return
     */
    public CMatrix findIndex(TMatrixOperator op, float x, String p1, String p2) {
        CMatrix ret = this.clone();

        ret = op.apply(ret, x, p1, p2);
        return ret;
    }

    /**
     * adaptive threshold could be performed, operates as Matlab's find method
     * try to find 1D indexes of the matrix based on the specified matrix
     * operator logical conditions returns cloned matrix indeed found indexes
     * are provided in int[] d parameter object
     *
     * @param op:logical criteria
     * @return
     */
    public CMatrix findIndex(TMatrixOperator op, float t1, float t2) {
        CMatrix ret = this.clone();

        ret = op.apply(ret, t1, t2);
        return ret;
    }

    /**
     * it is used for detecting the single any object in the image matrix and
     * crop the roi of the object from the matrix. it should be noted that
     * internally it is used nf=nearFactor which you should give as a parameter
     *
     * @param thr:threshold value for average pistachio
     * @param backgroundThr:threshold for background subtraction
     * @param nf:near factor how far object from the edge of the image matrix
     * @return cropped matrix related to the object itself
     */
    public CMatrix getWeightCenteredROI(int thr, int backgroundThr, int nf) {
        float[][] d = highPassFilter(this.array.dup().toFloatMatrix(), backgroundThr).array.dup().toFloatMatrix();
        d = FactoryUtils.getWeightCenteredROI(d, thr, nf);
        if (d != null) {
            setArray(d);
            return this;
        } else {
            return this;
        }
    }

    public TRoi getROIofWeightCenteredObject(int thr, int backgroundThr, int nf) {
        float[][] d = highPassFilter(this.array.dup().toFloatMatrix(), backgroundThr).array.dup().toFloatMatrix();
        TRoi roi = FactoryUtils.getRoiOfWeightCenteredObject(d, thr, nf);
        return roi;
    }

    public CMatrix getWeightCenteredROI() {
        float[][] d = FactoryUtils.getWeightCenteredROI(this.array.dup().toFloatMatrix());
        if (d != null) {
            setArray(d);
            return this;
        } else {
            return this;
        }
    }

    /**
     * Calculate the pixel area of the object in the scene
     *
     * @param thr: average pixel value of the object, you can determine this
     * value by otsu threshold also
     * @param isTextVisible: whether info will be written or not
     * @return
     */
    public CMatrix getObjectArea(int thr, boolean isTextVisible) {
        this.returnedValue.str = "" + FeatureExtractionPistachio.getPixelArea(this.array.toFloatMatrix(), thr);
        if (isTextVisible) {
            System.out.println("Calculated Object Area is:" + this.returnedValue.str);
        }
        return this;
    }

    public CMatrix getObjectArea() {
        this.returnedValue.str = "" + FeatureExtractionPistachio.getPixelArea(this.array.toFloatMatrix());
        return this;
    }

    /**
     * Matrix inversion
     *
     * @return
     */
    public CMatrix getInverse() {
        array = InvertMatrix.invert(array, false);
        return this;
    }

    /**
     * Matrix covariance
     *
     * @return covariance matrix
     */
    public CMatrix cov() {
//        array=PCA.covarianceMatrix(array)
        setArray(FactoryMatrix.cov(array.toFloatMatrix()));
        return this;
    }

    /**
     * Matrix covariance
     *
     * @return covariance value of only two subsequent column vectors
     */
    public CMatrix covValue() {
        CMatrix ret = this.clone();
        float[][] cov_d = FactoryMatrix.cov(ret.array.toFloatMatrix());
        float[] d = {cov_d[0][1]};
        ret = ret.setArray(d);
        ret.name = this.name + "|covariance value";
        return ret;
    }

    /**
     * Matrix correlation coefficient
     *
     * @return correlation coefficient matrix
     */
    public CMatrix corrcoef() {
        CMatrix ret = this.clone();
        float[][] corr = FactoryMatrix.corrcoef(ret.array.toFloatMatrix());
        ret = ret.setArray(corr);
        ret.name = this.name + "|correlation coefficient";
        return ret;
    }

    /**
     * Matrix correlation coefficient value
     *
     * @return correlation coefficient value
     */
    public CMatrix corrcoefValue() {
        CMatrix ret = this.clone();
        float[][] corr = FactoryMatrix.corrcoef(ret.array.toFloatMatrix());
        float[] d = {corr[0][1]};
        ret = ret.setArray(d);
        ret.name = this.name + "|correlation coefficient value";
        return ret;
    }

    /**
     * Matlab compatible command: Matrix inversion
     *
     * @return CMatrix
     */
    public CMatrix inv() {
        return getInverse();
    }

    /**
     * Matlab compatible command: Matrix pseudo inversion
     *
     * @return CMatrix
     */
    public CMatrix pinv() {
        array = InvertMatrix.pinvert(array, false);
        return this;
//        CMatrix ret = this.clone();
//
//        ret = ret.setArray(FactoryMatrix.pinv(ret.array));
//        return ret;
    }

    /**
     * Eigen Value Decomposition
     *
     * @return
     */
    public CMatrix getEigenValueDecompistion() {
        Matrix m = new Matrix(array.toDoubleMatrix());
        EigenvalueDecomposition eig = m.eig();
        m = eig.getD();
        setArray(m.getArray());
        return this;
    }

    /**
     * Matlab compatible command: Eigen Value Decomposition
     *
     * @return CMatrix
     */
    public CMatrix eig() {
        return getEigenValueDecompistion();
    }

    public CMatrix fromWekaMatrix(Matrix m) {
        CMatrix ret = this.clone();

        ret.setArray(m.getArray());
        return ret;
    }

    public Matrix toWekaMatrix() {
        return new Matrix(FactoryUtils.toDoubleArray2D(array.toFloatMatrix()));
    }

    public CMatrix deleteRow(int n) {
        ArrayList lst = this.toArrayList();
        lst.remove(n);
        return CMatrix.getInstance(lst);
    }

    public CMatrix deleteColumn(int n) {
        ArrayList lst = this.transpose().toArrayList();
        lst.remove(n);
        return CMatrix.getInstance(lst).transpose();
    }

    public CMatrix deleteRows(CMatrix m) {
        int[] p = m.toIntArray1D();
        ArrayList<float[]> lst = toArrayList();
        float[][] objList = new float[p.length][lst.get(0).length];
        for (int i = 0; i < p.length; i++) {
            objList[i] = lst.get(p[i]);
        }
        for (int i = 0; i < p.length; i++) {
            lst.remove(objList[i]);
        }
        CMatrix ret = fromArrayList(lst);
        ret.image = null;
        return ret;
    }

    public CMatrix deleteColumns(CMatrix m) {
        CMatrix ret = this.clone();
        int[] p = m.toIntArray1D();
        ArrayList<float[]> lst = this.clone().transpose().toArrayList();
        float[][] objList = new float[p.length][lst.get(0).length];
        for (int i = 0; i < p.length; i++) {
            objList[i] = lst.get(p[i]);
        }
        for (int i = 0; i < p.length; i++) {
            lst.remove(objList[i]);
        }
        ret = fromArrayList(lst).transpose();
        ret.image = null;
        return ret;
    }

    public float[] getRow(int i) {
        return array.toFloatMatrix()[i];
    }

    public CMatrix getRowMatrix(int i) {
        return CMatrix.getInstance(array.toFloatMatrix()[i]);
    }

    public float[] getColumn(int i) {
        return array.transpose().toFloatMatrix()[i];
    }

    public CMatrix getColumns(int startCol, int endCol) {
        endCol = endCol == -1 ? getColumnNumber() - 1 : endCol;
        int[] d = IntStream.range(startCol, endCol).toArray();
        array = array.dup().getColumns(d);
        return this;
    }

    public CMatrix getRows(int startRow, int endRow) {
        endRow = endRow == -1 ? getRowNumber() - 1 : endRow;
        int[] d = IntStream.range(startRow, endRow).toArray();
        array = array.dup().getRows(d);
        return this;
    }

    public float[] getLastColumn() {
        return array.transpose().toFloatMatrix()[getColumnNumber() - 1];
    }

    public CMatrix getColumnMatrix(int i) {
        return CMatrix.getInstance(array.transpose().toFloatMatrix()[i]);
    }

    /**
     * Sadece i. indexteki sutunun deÄŸerlerini parametre ile deÄŸiÅŸtirir, yeni
     * bir sÃ¼tÃ¼n eklemez
     *
     * @param n
     * @param p
     * @return
     */
    public CMatrix setColumn(int n, float[] p) {
        array = array.transpose();
        float[][] f = array.toFloatMatrix();
        for (int i = 0; i < p.length; i++) {
            f[n][i] = p[i];
        }
        setArray(f);
        array = array.transpose();
        return this;
    }

    /**
     * Sadece i. indexteki satÄ±rÄ±n deÄŸerlerini parametre ile deÄŸiÅŸtirir, yeni
     * bir satÄ±r eklemez
     *
     * @param i
     * @param p
     * @return
     */
    public CMatrix setRow(int i, float[] p) {
        float[][] f = array.toFloatMatrix();
        f[i] = p;
        setArray(f);
        return this;
    }

    public CMatrix setXY(int i, int j, float p) {
        array = array.putScalar(new int[]{i, j}, p);
        return this;
    }

    /**
     * parametresiz Ã§aÄŸrÄ±lÄ±rsa matrisin 0,0 elemanÄ±nÄ± geri gÃ¶nderir
     *
     * @return float
     */
    public float getValue() {
        return array.toFloatMatrix()[0][0];
    }

    /**
     * matrisin row ve column koordinatÄ±ndaki elemanÄ±nÄ± geri gÃ¶nderir.
     *
     * @param row
     * @param column
     * @return float
     */
    public float getValue(int row, int column) {
        return array.getFloat(row, column);
    }

    public float getValue(CPoint cp) {
        return array.getFloat(cp.row, cp.column);
    }

    public CMatrix imAlphaChannel() {
        return getAlphaChannelColor();
    }

    public CMatrix getAlphaChannelColor() {
        CMatrix ret = this.clone();
        ret.image = ImageProcess.getAlphaChannelColor(ret.image);
        setArray(ImageProcess.imageToPixelsFloat(ret.image));
        return ret;
    }

    public CMatrix imRedChannel() {
        return getRedChannelColor();
    }

    public CMatrix getRedChannelColor() {
        CMatrix ret = this.clone();
        ret.image = ImageProcess.getRedChannelColor(ret.image);
        setArray(ImageProcess.imageToPixelsFloat(ret.image));
        return ret;
    }

    public CMatrix imGreenChannel() {
        return getGreenChannelColor();
    }

    public CMatrix getGreenChannelColor() {
        CMatrix ret = this.clone();
        ret.image = ImageProcess.getGreenChannelColor(ret.image);
        setArray(ImageProcess.imageToPixelsFloat(ret.image));
        return ret;
    }

    public CMatrix imBlueChannel() {
        return getBlueChannelColor();
    }

    public CMatrix getBlueChannelColor() {
        CMatrix ret = this.clone();
        ret.image = ImageProcess.getBlueChannelColor(ret.image);
        setArray(ImageProcess.imageToPixelsFloat(ret.image));
        return ret;
    }

    public CMatrix resetMatrix() {
//        this.name = name;
//        this.array = FactoryUtils.to2DArrayDouble(ImageProcess.imageToPixels255(image));
//        this.rgbImageArray = FactoryUtils.to3DArrayDouble(ImageProcess.imageToPixels(image));
//        this.image = image;
        CMatrix ret = this.clone();

        return ret;
    }

    public ArrayList<float[]> toArrayList() {
        float[][] f = array.toFloatMatrix();
        ArrayList<float[]> ret = new ArrayList<>();
        for (int i = 0; i < f.length; i++) {
            ret.add(f[i]);
        }
        return ret;
    }

    public CMatrix fromArrayList(ArrayList<float[]> lst) {
        CMatrix ret = new CMatrix(lst.size(), lst.get(0).length);
        float[][] f = ret.toFloatArray2D();
        for (int i = 0; i < lst.size(); i++) {
            f[i] = lst.get(i);
        }
        ret = ret.setArray(f);
        return ret;
    }

    public CMatrix fromList(List lst) {
        CMatrix ret = new CMatrix(lst.toArray());
        return ret;
    }

    /**
     * add certain noise on the matrix elements
     *
     * @param range: how much noise
     * @param number : how many jitter noise points
     *
     * @return CMatrix
     */
    public CMatrix jitter(float range, int number) {
        float[][] r = array.dup().toFloatMatrix();
        float[][] f = array.dup().toFloatMatrix();
        Random rnd = new Random();
        for (int i = 0; i < number; i++) {
            for (int j = 0; j < this.getColumnNumber(); j++) {
                float n = (float) (rnd.nextGaussian() * range);
                r[i][j] = f[0][j] + n;
            }
        }
        setArray(r);
        return this;
    }

    /**
     * add certain noise on the matrix elements
     *
     * @param range: how much noise
     *
     * @return CMatrix
     */
    public CMatrix noise(float range) {
        return jitter(range);
    }

    /**
     * add certain noise on the matrix elements
     *
     * @param range: how much noise
     *
     * @return CMatrix
     */
    public CMatrix jitter(float range) {
        float[][] r = this.toFloatArray2D();// array.dup().toFloatMatrix();
        for (int i = 0; i < getRowNumber(); i++) {
            for (int j = 0; j < getColumnNumber(); j++) {
                float n = (float) (new Random().nextGaussian() * range);
                r[i][j] = r[i][j] + n;
            }
        }
        setArray(r);
        return this;
    }

    /**
     * add certain noise on the matrix elements
     *
     * @param range: how much noise
     *
     * @return CMatrix
     */
    public CMatrix addNoise(float range) {
        return jitter(range);
    }

    /**
     * Row wise randomly re-arrangement of the matrix elements
     *
     * @return CMatrix
     */
    public CMatrix shuffleRows() {
        int[] rows = randPermInt(getRowNumber());
        int nr = rows.length;
        float[][] f = new float[getRowNumber()][getColumnNumber()];
        float[][] d = array.dup().toFloatMatrix();
        for (int i = 0; i < nr; i++) {
            f[i] = d[rows[i]];
        }
        setArray(f);
        return this;
    }

    /**
     * Row wise randomly re-arrangement of the matrix elements
     *
     * @return CMatrix
     */
    public CMatrix shuffleRowsWeka() {
        CMatrix ret = this.clone();
        ret.name = this.name + "|shuffleRowsWeka";
        ret.wekaInstance.randomize(new Random(1));
        return ret;
    }

    /**
     * Row wise randomly re-arrangement of the matrix elements
     *
     * @return CMatrix
     */
    public CMatrix shuffleRowsWeka(int seed) {
        CMatrix ret = this.clone();

        ret.name = this.name + "|shuffleRowsWeka";
        ret.wekaInstance.randomize(new Random(seed));
        return ret;
    }

    /**
     * Column wise randomly re-arrangement of the matrix elements
     *
     * @return CMatrix
     */
    public CMatrix shuffleColumns() {
        int[] cols = randPermInt(getColumnNumber());
        int ncols = cols.length;
        float[][] f = array.dup().transpose().toFloatMatrix();
        float[][] d = new float[ncols][getRowNumber()];
        for (int i = 0; i < ncols; i++) {
            d[i] = f[cols[i]];
        }
        setArray(d);
        array = array.transpose();
        return this;
    }

    /**
     * Matlab compatible command::read image file
     *
     * @return CMatrix
     */
    public CMatrix imread() {
        return readImage();
    }

    /**
     * Matlab and Python compatible command::read image file
     *
     * @return CMatrix
     */
    public CMatrix imread(File file) {
        this.readImage(file.getAbsolutePath());
        return this;
    }

    public CMatrix imsave() {
        return saveImage();
    }

    public CMatrix imsave_atFolder(String folderPath, String fileName) {
        return saveImageAtFolder(folderPath + "/" + fileName);
    }

    public CMatrix imsave_atFolder(String withFolderPath) {
        return saveImageAtFolder(withFolderPath);
    }

    public CMatrix imsave(String path) {
        return saveImage(path);
    }

    public CMatrix imsave(String folderPath, String fileName) {
        return saveImage(folderPath, fileName);
    }

    /**
     * Matlab compatible command::write image file
     *
     * @return CMatrix
     */
    public CMatrix imwrite() {
        return writeImage();
    }

    public CMatrix writeImage() {
        ImageProcess.writeImage(image);
        return this;
    }

    /**
     * Matlab compatible command::write image file
     *
     * @return CMatrix
     */
    public CMatrix imwrite(String path) {
        return writeImage(path);
    }

    public CMatrix writeImage(String path) {
        ImageProcess.writeImage(image, path);
        return this;
    }

    /**
     *
     * @param width
     * @param height
     *
     * @return CMatrix
     */
    public CMatrix imcrop(int px, int py, int width, int height) {
        return cmd(py + ":" + (py + height), px + ":" + (px + width));
    }

    /**
     * Matlab compatible command:read image file from the provided path
     *
     * @param path:image file path
     *
     * @return CMatrix
     */
    public CMatrix imread(String path) {
        File file=new File(path);
        String ek;
        if (file.getName().indexOf(".")==-1) {
            File[] files=FactoryUtils.getFileListInFolderForImages(path);
            if (files.length>=0) {
                path+="\\"+files[0].getName();
            }
        }
        this.imagePath = path;
        return readImage(path);
    }

    public CMatrix imremove(String path) {
        FactoryUtils.deleteFile(path);
        return this;
    }

    public CMatrix readImage() {
        File fl = ImageProcess.readImage();
        BufferedImage bf = ImageProcess.readImageFromFile(fl);
//        CMatrix ret = this.clone();
        if (bf != null) {
            this.image = bf;
//            this.array = FactoryUtils.toDoubleArray(ImageProcess.imageToPixels255(image));
//            ret.array = ImageProcess.imageToPixelsDouble(GrayScale.luminosity(image));
            this.imagePath = fl.getAbsolutePath();
            setArray(ImageProcess.bufferedImageToArray2D(this.image));
//            this.rgbImageArray = FactoryUtils.toTripleArray(ImageProcess.imageToPixels(image));
        }
        return this;
    }

    public CMatrix readImage(String path) {
//        BufferedImage bf = ImageProcess.readImageFromFile(path);
//        if (bf != null) {
//            Path p = Paths.get(path);
//            String fileName = p.getFileName().toString();
//            this.name += "|" + fileName;
//            this.image = bf;
////            this.array = ImageProcess.imageToDoublePixels255(this.image);
//            this.array = ImageProcess.imageToPixelsDouble(GrayScale.luminosity(image));
//            this.imagePath = path;
//        } else {
//            System.err.println("null pointer exception, image could not be loaded properly");
//        }
        this.image = ImageProcess.readImage(path);
        setArray(ImageProcess.bufferedImageToArray2D(this.image));
        this.imagePath = path;
        return this;
    }

    public CMatrix normalizeZScore() {
        setArray(FactoryNormalization.normalizeZScore(array.toFloatMatrix()));
        return this;
    }

    /**
     * Matlab compatible command: normalize each columns by zscore normalization
     * technique
     *
     * @return CMatrix
     */
    public CMatrix zscore() {
        return normalizeZScore();
    }

    public CMatrix normalizeMinMax() {
        setArray(FactoryNormalization.normalizeMinMax(array.toFloatMatrix()));
        return this;
    }

    /**
     * Matlab compatible command: get minimum and maximum values of each rows
     *
     * @return CMatrix
     */
    public CMatrix minmax() {
        return normalizeMinMax();
    }

    public CMatrix normalizeWithRange(float min, float max) {
        setArray(FactoryNormalization.normalizeWithRange(array.toFloatMatrix(), min, max));
        return this;
    }

    public CMatrix normalizeWithRangeRows(float min, float max) {
        setArray(FactoryNormalization.normalizeWithRange(array.dup().transpose().toFloatMatrix(), min, max));
        array = array.transpose();
        return this;
    }

    public CMatrix map(float min, float max) {
        return normalizeWithRange(min, max);
    }

    public CMatrix mapRows(float min, float max) {
        return normalizeWithRangeRows(min, max);
    }

    public CMatrix multiplyElement(CMatrix cm) {
        array = array.muli(cm.array);
        return this;
    }

    public CMatrix divideElement(CMatrix cm) {
        array = array.divi(cm.array);
        return this;
    }

    public CMatrix and(CMatrix cm) {
        if (this.getRowNumber() != cm.getRowNumber() || this.getColumnNumber() != cm.getColumnNumber()) {
            System.err.println("Two Matrixes should be the same size");
            return this;
        }
        float[][] d1 = array.toFloatMatrix();
        float[][] d2 = cm.array.toFloatMatrix();
        float[][] d3 = new float[getRowNumber()][getColumnNumber()];
        for (int i = 0; i < d1.length; i++) {
            for (int j = 0; j < d1[0].length; j++) {
                d3[i][j] = (int) d1[i][j] & (int) d2[i][j];
            }
        }
        setArray(d3);
        return this;
    }

    public CMatrix or(CMatrix cm) {
        if (this.getRowNumber() != cm.getRowNumber() || this.getColumnNumber() != cm.getColumnNumber()) {
            System.err.println("Two Matrixes should be the same size");
            return this;
        }
        float[][] d1 = array.toFloatMatrix();
        float[][] d2 = cm.array.toFloatMatrix();
        float[][] d3 = new float[getRowNumber()][getColumnNumber()];
        for (int i = 0; i < d1.length; i++) {
            for (int j = 0; j < d1[0].length; j++) {
                d3[i][j] = (int) d1[i][j] | (int) d2[i][j];
            }
        }
        setArray(d3);
        return this;
    }

    public CMatrix xor(CMatrix cm) {
        if (this.getRowNumber() != cm.getRowNumber() || this.getColumnNumber() != cm.getColumnNumber()) {
            System.err.println("Two Matrixes should be the same size");
            return this;
        }
        float[][] d1 = array.toFloatMatrix();
        float[][] d2 = cm.array.toFloatMatrix();
        float[][] d3 = new float[getRowNumber()][getColumnNumber()];
        for (int i = 0; i < d1.length; i++) {
            for (int j = 0; j < d1[0].length; j++) {
                d3[i][j] = (int) d1[i][j] ^ (int) d2[i][j];
            }
        }
        setArray(d3);
        return this;
    }

    public CMatrix not() {
        float[][] d1 = array.toFloatMatrix();
        float[][] d3 = new float[getRowNumber()][getColumnNumber()];
        for (int i = 0; i < d1.length; i++) {
            for (int j = 0; j < d1[0].length; j++) {
                d3[i][j] = ~(int) d1[i][j];
            }
        }
        setArray(d3);
        return this;
    }

    /**
     * Matlab compatible command: transform matrix items 1,0,-1 if greater than
     * 0 and if equals 0 and if smaller than 0, respectively
     *
     *
     * @return CMatrix
     */
    public CMatrix sign() {
        return getSignum();
    }

    /**
     * Matlab compilant command: transform matrix items 1,0,-1 if greater than t
     * and if equals t and if smaller than t, respectively
     *
     * @param t : threshold
     *
     * @return CMatrix
     */
    public CMatrix sign(int t) {
        return getSignum(t);
    }

    /**
     * signum is a sign function which satisfies three conditions |-1 :x less
     * than 0 signum(x)=| 0 :x=0 |+1 :x greater than 0
     *
     * @return
     */
    public CMatrix getSignum() {
        float[][] d = array.toFloatMatrix();
        float[][] d1 = new float[getRowNumber()][getColumnNumber()];
        for (int i = 0; i < d.length; i++) {
            for (int j = 0; j < d[0].length; j++) {
                d1[i][j] = (i == 0) ? 0 : (i > 0) ? 1 : -1;
            }
        }
        setArray(d1);
        return this;
    }

    /**
     * transform matrix items 1,0,-1 if greater than t and if equals t and if
     * smaller than t, respectively
     *
     * @param t : threshold
     *
     * @return CMatrix
     */
    public CMatrix getSignum(int t) {
        float[][] d = array.toFloatMatrix();
        float[][] d1 = new float[getRowNumber()][getColumnNumber()];
        for (int i = 0; i < d.length; i++) {
            for (int j = 0; j < d[0].length; j++) {
                d1[i][j] = (i > t) ? 1 : (i < t) ? -1 : 0;
            }
        }
        setArray(d1);
        return this;
    }

    /**
     * Basic Statistics Functions here
     *
     * @return
     */
    public float getInverseDiffMoment() {
        float IDF = 0.0f;
        float[][] f = array.dup().toFloatMatrix();
        for (int i = 0; i < getRowNumber(); i++) {
            for (int j = 0; j < getColumnNumber(); j++) {
                IDF += f[i][j] / (1 + (i - j) * (i - j));
            }
        }
        return IDF;
    }

    public CMatrix getContrast(int paramInt) {
        int i;
        int[] contrast = new int[256];
        if (paramInt < 0) {
            int j = 0;
            do {
                i = j > 127 ? 255 - j : j;
                i = (int) (127.0D * Math.pow((i > 0 ? i : 1) / 127.0D, (127 + paramInt) / 127.0D));
                if (i > 255) {
                    i = 255;
                } else if (i < 0) {
                    i = 0;
                }
                contrast[j] = (j > 127 ? 255 - i : i);
                j++;
            } while (j < 256);
        } else {
            int j = 0;
            do {
                i = j > 127 ? 255 - j : j;
                float d = (paramInt == 127) ? 127.0f : (127.0f / (127 - paramInt));
                i = (int) (127.0D * Math.pow(i / 127.0D, d));
                if (i > 255) {
                    i = 255;
                } else if (i < 0) {
                    i = 0;
                }
                contrast[j] = (j > 127 ? 255 - i : i);
                j++;
            } while (j < 256);
        }
        CMatrix ret = this.clone();

        ret.setArray(contrast);
        return ret;
    }

    /**
     * As far as we know contrast means dynamic range of the image here dynamic
     * range represents absolute difference value of max and min values
     *
     * @return
     */
    public float getContrast() {
        float contrast = 0.0f;
        float[] hist = FactoryUtils.toFloatArray1D(getImageHistogramData().array.toFloatMatrix());
        float max = 0;
        float min = 0;
        for (int i = 0; i < hist.length; i++) {
            if (hist[i] > 0) {
                min = i;
                break;
            }
        }
        for (int i = hist.length - 1; i > 0; i--) {
            if (hist[i] > 0) {
                max = i;
                break;
            }
        }
        contrast = Math.abs(max - min);
        return contrast;
    }

    /**
     * Matlab compatible command: calculate contrast value
     *
     * @return
     */
    public CMatrix contrast() {
        CMatrix ret = this.clone();

        ret.returnedValue.str = "" + getContrast();
        return ret;
    }

    /**
     * Matlab compatible command: calculate contrast value
     *
     * @param k : threshold value
     *
     * @return CMatrix
     */
    public CMatrix contrast(int k) {
        return getContrast(k);
    }

    /**
     * Matlab compatible command: calculate entropy value based on columns
     *
     * @return CMatrix
     */
    public CMatrix entropy() {
        CMatrix ret = this.clone();
        ret.setArray(ret.getColumnEntropy());
        ret.returnedValue.str = "" + getEntropy();
        return ret;
    }

    /**
     * calculate entropy values of each columns
     *
     * @return float[]
     */
    public float[] getColumnEntropy() {
        int nc = this.getColumnNumber();
        float[] entropies = new float[nc];
        for (int i = 0; i < nc; i++) {
            entropies[i] = this.cmd(":", "" + i).getEntropy();
        }
        return entropies;
    }

    public float getEntropy() {
        return array.entropyNumber().floatValue();
//        float entropy = 0.0f;
//        float[] pdfArray = FactoryUtils.toFloatArray1D(getPDFData().array.toFloatMatrix());
//        for (int i = 0; i < pdfArray.length; i++) {
//            if (pdfArray[i] >= 0 && pdfArray[i] <= 0.000001) {
//                continue;
//            }
//            entropy += pdfArray[i] * Math.log(pdfArray[i]);
//        }
//        entropy = -entropy;
//        return entropy;
    }

    /**
     * Matlab compatible command: calculate energy value based on columns
     *
     * @return CMatrix
     */
    public CMatrix energy() {
        CMatrix ret = this.clone();
        ret.setArray(ret.getColumnEnergy());
        ret.returnedValue.str = "" + getEnergy();
        return ret;
    }

    /**
     * calculate energy values of each columns
     *
     * @return float[]
     */
    public float[] getColumnEnergy() {
        int nc = this.getColumnNumber();
        float[] energies = new float[nc];
        for (int i = 0; i < nc; i++) {
            energies[i] = this.cmd(":", "" + i).getEnergy();
        }
        return energies;
    }

    public float getEnergy() {
        float energy = 0.0f;
        float[][] f = array.toFloatMatrix();
        for (int i = 0; i < getRowNumber(); i++) {
            for (int j = 0; j < getColumnNumber(); j++) {
                energy += f[i][j] * f[i][j];
            }
        }
        return energy;
    }

    /**
     * Matlab compatible command: calculate kurtosis value based on columns
     *
     * @return CMatrix
     */
    public CMatrix kurtosis() {
        CMatrix ret = this.clone();
        ret.setArray(ret.getColumnKurtosis());
        ret.returnedValue.str = "" + getKurtosis();
        return ret;
    }

    /**
     * calculate energy values of each columns
     *
     * @return float[]
     */
    public float[] getColumnKurtosis() {
        int nc = this.getColumnNumber();
        float[] kurtosis = new float[nc];
        for (int j = 0; j < nc; j++) {
            kurtosis[j] = this.cmd(":", "" + j).getKurtosis();
        }
        return kurtosis;
    }

    public float getKurtosis() {
        int[] nums = toIntArray1D();
        int n = nums.length;
        float mean = FactoryUtils.getMean(nums);
        float deviation = 0.0f;
        float variance = 0.0f;
        float k = 0.0f;

        for (int i = 0; i < n; i++) {
            deviation = nums[i] - mean;
            variance += Math.pow(deviation, 2);
            k += Math.pow(deviation, 4);
        }
        //variance /= (n - 1);
        variance = variance / n;
        if (variance != 0.0) {
            //k = k / (n * variance * variance) - 3.0;
            k = k / (n * variance * variance);
        }
        return k;
    }

    /**
     * retrieve image histogram in range (0..255) by default
     *
     * @return
     */
    public CMatrix getHistogram() {
        float[] d = FactoryMatrix.getHistogram(array.toFloatMatrix(), 256);
        setArray(d);
        return this;
    }

    /**
     * retrieve image histogram for nBins
     *
     * @param nBins
     * @return
     */
    public CMatrix getHistogram(int nBins) {
        return hist(nBins);
    }

    /**
     * Matlab compatible command: calculate skewness value based on columns
     *
     * @return CMatrix
     */
    public CMatrix skewness() {
        setArray(getColumnSkewness());
        returnedValue.str = "" + getSkewness();
        return this;
    }

    /**
     * calculate skewness values of each columns
     *
     * @return float[]
     */
    public float[] getColumnSkewness() {
        int nc = this.getColumnNumber();
        float[] skewness = new float[nc];
        for (int j = 0; j < nc; j++) {
            skewness[j] = this.cmd(":", "" + j).getSkewness();
        }
        return skewness;
    }

    public float getSkewness() {
        float[] nums = array.toFloatVector();
        int n = nums.length;
        float mean = FactoryUtils.getMean(nums);
        float deviation = 0.0f;
        float variance = 0.0f;
        float skew = 0.0f;

        for (int i = 0; i < n; i++) {
            deviation = nums[i] - mean;
            variance += Math.pow(deviation, 2);
            skew += Math.pow(deviation, 3);
        }
        //variance /= (n - 1);
        variance /= n;
        float standard_deviation = (float) Math.sqrt(variance);
        if (variance != 0.0) {
            skew /= (n * variance * standard_deviation);
        }
        return skew;
    }

    public float getAdaptiveExposureScore() {
        float d = getAdaptiveExposureMatrix().sumTotal();
//        if (d >= 0) {
//            d = Math.pow(d, 1.0 / 16);
//        } else {
//            d = -Math.pow(Math.abs(d), 1.0 / 16);
//        }
//        return d + 8;
        return d;
    }

    /**
     * adaptive exposure score un Ã§alÄ±ÅŸma mantÄ±ÄŸÄ± ÅŸu ÅŸekilde Ã¶zetlenebilir
     * hiperspektral gÃ¶rÃ¼ntÃ¼lerde veya diÄŸer gÃ¶rÃ¼ntÃ¼lerde uÃ§ deÄŸerler mesela 0
     * ve 255 parlaklÄ±k deÄŸerleri under expose ve over expose sÄ±nÄ±rÄ± olduÄŸundan,
     * en uÃ§ deÄŸerlere en fazla ceza verecek ve ortaya yani 127 griye geldiÄŸinde
     * ise ceza seviyesi Ã§ok radikal bir ÅŸekilde dÃ¼ÅŸecek bir higher order
     * non-linear bir fonksiyon ile Ã§arpmak veya convolution almak gerekiyor.
     * Hiperspketral gÃ¶rÃ¼ntÃ¼ler genellikle hiÃ§ bir zaman 0 deÄŸerinden
     * baÅŸlamadÄ±ÄŸÄ± iÃ§in total hesaplandÄ±ktan sonra bir eÅŸik deÄŸeri ile saÄŸa
     * doÄŸru shift edilmiÅŸtir. DiÄŸer gÃ¶rÃ¼ntÃ¼ler iÃ§in bu doÄŸru olmayabilir.
     *
     * @return
     */
    public CMatrix getAdaptiveExposureMatrix() {
        int n = 24;
        CMatrix y1 = CMatrix.getInstance().range(0, 127).minusScalar(127).pow(n);
        CMatrix y2 = CMatrix.getInstance().range(128, 255).minusScalar(128).pow(n);
        CMatrix y = y1.cat(2, y2).normalizeMinMax();

//        CMatrix y = CMatrix.getInstance().vector(0, 255).minusScalar(127).pow(8).normalizeMinMax().plot();
        CMatrix pdf = CMatrix.getInstance(this.image).getPDFData();
        CMatrix target = y.multiplyElement(pdf).multiplyElement(y.sign(127));//.plot();//.scale(1.0 / (this.image.getWidth() * this.image.getHeight() / 300));
        return target;
    }

    /**
     * Matlab compatible command: add original to cmx
     *
     * @param cmx : added matrix
     *
     * @return CMatrix
     */
    public CMatrix add(CMatrix cmx) {
        array = array.add(cmx.array);
        return this;
    }

    /**
     * row numbers should be identical added matrix should have single column
     * addition takes place on each column of original matrix
     *
     * @param cmx : added matrix
     *
     * @return CMatrix
     */
//    public CMatrix addSignal(CMatrix cmx) {
//        CMatrix ret = this.clone();
//
//        for (int i = 0; i < this.getRowNumber(); i++) {
//            for (int j = 0; j < this.getColumnNumber(); j++) {
//                ret.array[i][j] = this.array[i][j] + cmx.array[i][0];
//            }
//        }
//        return ret;
//    }
    /**
     * Matlab compatible command: Subtract cmx from original matrix
     *
     * @param cmx : subtracted matrix
     *
     * @return CMatrix
     */
    public CMatrix minus(CMatrix cmx) {
        array = array.sub(cmx.array);
        return this;
    }

    public CMatrix difference(CMatrix cmx) {
        array = array.sub(cmx.array);
        return this;
    }

    public CMatrix absDifference(CMatrix cmx) {
        array = Transforms.abs(array.sub(cmx.array));
        return this;
    }

    public CMatrix filterMedian(int window_size) {
        image = ImageProcess.filterMedian(image, window_size);
        setArray(ImageProcess.imageToPixelsFloat(image));
        return this;
    }

    /**
     * Matlab compliant median filter default window size is 3x3
     *
     * @return
     */
    public CMatrix medfilt2() {
        return medfilt2(3);
    }

    /**
     * Matlab compliant median filter with a given window size for 2D image
     * matrix
     *
     * @return
     */
    public CMatrix medfilt2(int window_size) {
        image = ImageProcess.filterMedian(image, window_size);
        setArray(ImageProcess.imageToPixelsFloat(image));
        return this;
    }

    /**
     * Matlab compatible median filter default window size is 3x3
     *
     * @return
     */
    public CMatrix meanfilt1() {
        return meanfilt1(3);
    }

    /**
     * Matlab compatible median filter with a given window size for 2D image
     * matrix
     *
     * @param window_size: size of the used kernel or window
     * @return
     */
    public CMatrix meanfilt1(int window_size) {
        return filterMean1D(window_size);
    }

    /**
     * apply mean filter
     *
     * @param window_size
     * @return
     */
    public CMatrix filterMean1D(int window_size) {
        float[] d = FactoryMatrix.filterMean1D(array.toFloatVector(), window_size);
        setArray(d);
        return this;
    }

    /**
     * Matlab compatible median filter default window size is 3x3
     *
     * @return
     */
    public CMatrix medfilt1() {
        return medfilt1(3);
    }

    /**
     * Matlab compatible median filter with a given window size for 2D image
     * matrix
     *
     * @param window_size: size of the used kernel or window
     * @return
     */
    public CMatrix medfilt1(int window_size) {
        return filterMedian1D(window_size);
    }

    public CMatrix filterMedian1D(int window_size) {
        float[] d = FactoryMatrix.filterMedian1D(array.toFloatVector(), window_size);
        setArray(d);
        return this;
    }

    public CMatrix filterGaussian(int window_size) {
        image = ImageProcess.filterGaussian(image, window_size);
        setArray(ImageProcess.imageToPixelsFloat(image));
        return this;
    }

    public CMatrix filterMembershipFunction(CMatrix cm) {
        float[][] d = FactoryMatrix.filterMembershipFunction(array.toFloatMatrix(), cm.array.toFloatVector());
        setArray(d);
        return this;
    }

    /**
     * apply mean filter
     *
     * @param window_size
     * @return
     */
    public CMatrix filterMean(int window_size) {
        image = ImageProcess.filterMean(image);
        setArray(ImageProcess.bufferedImageToArray2D(image));
        return this;
    }

    /**
     * apply mean filter
     *
     * @param window_size
     * @return
     */
    public CMatrix filterMotionBlur() {
        image = ImageProcess.filterMotionBlur(image);
        setArray(ImageProcess.bufferedImageToArray2D(image));
        return this;
    }

    /**
     * Matlab compatible mean filter or average filter for 2D image matrix with
     * a given size of window
     *
     * @param window_size
     * @return
     */
    public CMatrix filter2(int window_size) {
        image = ImageProcess.filterMean(image, window_size);
        setArray(ImageProcess.imageToPixelsFloat(image));
        return this;
    }

    /**
     * Matlab compliant mean filter or average filter for 2D image matrix
     *
     * @return
     */
    public CMatrix filter2() {
        return filter2(3);
    }

    /**
     * column wised number of peaks in the matrix signals
     *
     * @return CMatrix
     */
    public CMatrix getNumberOfPeaks() {
        float[] peaks = FactoryUtils.getNumberOfPeaks(array.toFloatMatrix());
        setArray(peaks);
        array = array.transpose();
        return this;
    }

    /**
     * column wised number of peaks in the matrix signals
     *
     * @return
     */
    public CMatrix getAverageNumberOfPeaks() {
        int length = array.rows();
        float[] peaks = FactoryUtils.getNumberOfPeaks(array.toFloatMatrix());
        for (int i = 0; i < peaks.length; i++) {
            peaks[i] = peaks[i] / length;
        }
        setArray(peaks);
        array = array.transpose();
        return this;
    }

    public CMatrix getAverageTotalMovement() {
        int length = array.rows();
        float[] movs = FactoryUtils.getTotalMovement(array.toFloatMatrix());
        for (int i = 0; i < movs.length; i++) {
            movs[i] = movs[i] / length;
        }
        setArray(movs);
        array = array.transpose();
        return this;
    }

    /**
     * compute combination of n subset of the string array you can get the
     * result by means of combinationPairs array defined in CMatrix as public
     * access modifier
     *
     * @param lst
     * @param n
     * @return
     */
    public CMatrix combinationPairs(String[] lst, int n) {
        String[] s = FactoryCombination.getCombination(lst, n);
        combinationPairs = s;
        return this;
    }

    /**
     * compute combination of n subset of the char array you can get the result
     * by means of combinationPairs array defined in CMatrix as public access
     * modifier
     *
     * @param lst
     * @param n
     * @return
     */
    public CMatrix combinationPairs(char[] lst, int n) {
        String[] s = FactoryCombination.getCombination(FactoryMatrix.toStringArray(lst), n);
        combinationPairs = s;
        return this;
    }

    /**
     * compute permutation of n subset of the string array you can get the
     * result by means of permutationPairs array defined in CMatrix as public
     * access modifier
     *
     * @param lst
     * @param n
     * @return
     */
    public CMatrix permutationPairs(char[] lst, int n) {
        CMatrix ret = this.clone();

        List<String> list = new ArrayList();
        String[] ss = FactoryCombination.getCombination(FactoryMatrix.toStringArray(lst), n);
        int k = 0;
        for (int i = 0; i < ss.length; i++) {
            String[] s = FactoryPermutation.getPermutation(ss[i].replace(",", "").toCharArray());
            for (int j = 0; j < s.length; j++) {
                list.add(s[j]);
            }
        }
        ret.permutationPairs = new String[list.size()];
        for (int i = 0; i < list.size(); i++) {
            ret.permutationPairs[i] = list.get(i);
        }
        return ret;
    }

    /**
     * Matlab compatible command: calculate C(n,k) value
     *
     * @param n : size of the superset
     * @param k : size of the subset
     * @return CMatrix
     */
    public CMatrix nchoosek(int n, int k) {
        CMatrix ret = this.clone();
        if (n < k) {
            System.out.println("for combination calculation first parameter should greater thand second one");
            ret.returnedValue.str = -1 + "";
        }
        ret.returnedValue.str = "" + FactoryUtils.combination(n, k);
        return ret;
    }

    /**
     * return the biggest size of the dimension in the matrix
     *
     * @return
     */
    public int getMaxDimSize() {
        int max = this.getColumnNumber();
        if (this.getRowNumber() > max) {
            return this.getRowNumber();
        }
        return max;
    }

    /**
     * return the biggest size of the dimension in the matrix
     *
     * @return
     */
    public int maxsize() {
        return getMaxDimSize();
    }

    /**
     * return the biggest size of the dimension in matrix parameter cm
     *
     * @param cm : CMatrix
     * @return biggest dimension size
     */
    public int getMaxDimSize(CMatrix cm) {
        int max = cm.getColumnNumber();
        if (cm.getRowNumber() > max) {
            return cm.getRowNumber();
        }
        return max;
    }

    /**
     * return the biggest size of the dimension in matrix parameter cm
     *
     * @param cm : CMatrix
     * @return biggest dimension size
     */
    public int maxsize(CMatrix cm) {
        return getMaxDimSize(cm);
    }

//    
//    public CMatrix allcomb(int n){
//        
//    }
    /**
     * Matlab compatible command:
     *
     * Matlabdaki cat yani concatenate ile benzemektedir ayrÄ±ca merge metodunun
     * birebir aynÄ±sÄ±dÄ±r matlab uyumluluÄŸu iÃ§in eklenmiÅŸtir.
     *
     * FarkÄ± ÅŸudur Matlabdaki cat fonksiyonu, dim paramtresinden sonra iki adet
     * matris alÄ±r bunlarÄ± ekler eÄŸer dim 1 ise horzcat, 2 ise vertcat
     * fonksiyonlarÄ±nÄ±n iÅŸini gÃ¶rÃ¼r veya dim 1 ise [A B] yapar 2 ise [A;B] yapar
     *
     * OCL de ise cat sadece bir matrise ihtiyaÃ§ duyar, Ã§Ã¼nkÃ¼ this de zaten
     * birinci matris vardÄ±r
     *
     * @param dim 1=yatay ekleme; 2=dikey ekleme
     * @param cm eklemek istenilen matris sona eklenir(note that matrix
     * dimension should be appropriate along with the dimension) i.e. if
     * dimension is set to 1 means that horizontal concetanation is desired, so
     * matrix number of rows should be identical to eachother. And vice versa.
     *
     * @return CMatrix
     */
    public CMatrix cat(int dim, CMatrix cm) {
        if (dim == 1) {
            if (getRowNumber() != cm.getRowNumber()) {
                System.out.println("Matrix first dimension (number of rows) should be the same as the base matrix");
                return this;
            }
            array = Nd4j.concat(dim, array, cm.array);
        }
        if (dim == 2) {
            if (getColumnNumber() != cm.getColumnNumber()) {
                System.out.println("Matrix second dimension (number of columns) should be the same as the base matrix");
                return this;
            }
            array = Nd4j.concat(dim - 2, array, cm.array);
        }
        image = null;
        return this;
    }

    /**
     * Matlab Compatibility
     *
     *
     * Eklenecek matrisi baÅŸa alÄ±p ekler normal cat ise sona ekler Matlabdaki
     * cat yani concatenate fonksiyonuna banzer farkÄ± ÅŸudur Matlabdaki cat
     * fonksiyonu, dim paramtresinden sonra iki adet matris alÄ±r bunlarÄ± ekler
     * eÄŸer dim 1 ise horzcat, 2 ise vertcat fonksiyonlarÄ±nÄ±n iÅŸini gÃ¶rÃ¼r veya
     * dim 1 ise [A B] yapar 2 ise [A;B] yapar OCL de ise cat sadece bir matrise
     * ihtiyaÃ§ duyar, Ã§Ã¼nkÃ¼ this de zaten birinci matris vardÄ±r.
     *
     * @param dim :1=horizontal ; 2=vertical
     * @param cm :matrix that is desired to concatenate tries to concatenate at
     * the begining of the original matrix (note that matrix dimension should be
     * appropriate along with the dimension) i.e. if dimension is set to 1 means
     * that horizontal concetanation is desired, so matrix number of rows should
     * be identical to eachother. And vice versa.
     *
     * @return CMatrix
     */
    public CMatrix catFirst(int dim, CMatrix cm) {
        if (dim == 1) {
            if (getRowNumber() != cm.getRowNumber()) {
                System.out.println("Matrix first dimension (number of rows) should be the same as the base matrix");
                return this;
            }
            array = Nd4j.concat(dim - 1, cm.array, array);
        }
        if (dim == 2) {
            if (getColumnNumber() != cm.getColumnNumber()) {
                System.out.println("Matrix second dimension (number of columns) should be the same as the base matrix");
                return this;
            }
            array = Nd4j.concat(dim - 1, cm.array, array);
        }
        image = null;
        return this;
    }

    /**
     * Matlab compatible command: for Matlab Compatibility initialize timer
     * (System.nanoTime() is called for perfect calculation of elapsed time)
     *
     * @return CMatrix
     */
    public CMatrix tic() {
        currentTime = System.nanoTime();
        return this;
    }

    /**
     * Matlab compatible command: for Matlab Compatibility print elapsed time
     * from tic() to toc() in second (System.nanoTime() is called for perfect
     * calculation of elapsed time)
     *
     * @return CMatrix
     */
    public CMatrix toc() {
        long t2 = System.nanoTime();
        float elapsed = (t2 - currentTime) / 1000000.0f;
        System.out.println("Elapsed Time:" + elapsed + " ms");
        currentTime = System.nanoTime();
        return this;
    }

    public CMatrix toc(String msg) {
        long t2 = System.nanoTime();
        float elapsed = (t2 - currentTime) / 1000000.0f;
        System.out.println(msg + " Elapsed Time:" + elapsed + " miliSecond");
        currentTime = System.nanoTime();
        return this;
    }

    /**
     * Matlab compatible command: compute gauss (normal) membership function for
     * a given mean and standart deviation values
     *
     * @param sigma : standart deviation value
     * @param mean : Mean value
     * @return CMatrix
     */
    public CMatrix gaussmf(float sigma, float mean) {
        array = array.transpose();
        setArray(FactoryUtils.gaussian(array.toFloatMatrix(), sigma, mean));
        return this;
    }

    /**
     * Matlab compatible command:Resize the matrix to desired width and height
     * values w:width h:height
     *
     * @param w : width
     * @param h : height
     * @return CMatrix
     */
    public CMatrix imresize(int w, int h) {
        if (image == null) {
            image = ImageProcess.pixelsToImageGray(array.toFloatMatrix());
        }
        image = ImageProcess.resize(image, w, h);
        setArray(ImageProcess.imageToPixelsFloat(image));
        return this;
    }

    /**
     * Matlab compatible command:Resize the matrix to desired width and height
     * values w:width h:height given RenderingHint param
     *
     * @param w : width
     * @param h : height
     * @return CMatrix
     */
    public CMatrix imresize(int w, int h, Object rh) {
        if (image == null) {
            image = ImageProcess.pixelsToImageGray(array.toFloatMatrix());
        }
        image = ImageProcess.resize(image, w, h, rh);
        setArray(ImageProcess.imageToPixelsFloat(image));
        return this;
    }

    public CMatrix imresizeSmooth(int w, int h) {
        image = ImageProcess.resizeSmooth(image, w, h);
        setArray(ImageProcess.imageToPixelsFloat(image));
        return this;
    }

    public CMatrix imresize(CSize c) {
        return imresize(c.width, c.height);
    }

    /**
     * resize image with ratio. ie. if ratio is 0.5 it scales image to half size
     * if ratio is 2 it scales image to float size
     *
     * @param ratio
     * @return
     */
    public CMatrix imresize(float ratio) {
        int w = (int) (this.getColumnNumber() * ratio);
        int h = (int) (this.getRowNumber() * ratio);
        return imresize(w, h);
    }

    /**
     * resize image keeping aspect ratio but for the desired square size which
     * is suitable for example mobilenet 224x224 input images
     *
     * @param ratio
     * @return
     */
    public CMatrix imresizeWithAspectRatio(int size) {
        int w = getColumnNumber();
        int h = getRowNumber();
        int d_w = w - size;
        int d_h = h - size;
        float ratio = 0;
        if (d_h < d_w) {
            ratio = 1.0f * size / h;
        } else {
            ratio = 1.0f * size / w;
        }
        imresize(ratio);
        w = getColumnNumber();
        h = getRowNumber();
        if (w <= size && h <= size) {
            imresize(size + 1, size + 1);
        } else if (w <= size) {
            imresize(size + 1, h);
        } else if (h <= size) {
            imresize(w, size + 1);

        }
        w = getColumnNumber();
        h = getRowNumber();
        int pr = (h - size) / 2;
        int pc = (w - size) / 2;

        return cmd(pr + ":" + (pr + size), pc + ":" + (pc + size));
    }

    public CMatrix imblend(CMatrix cm, float alpha) {
        return overlay(cm, alpha);
    }

    public CMatrix imblend(CMatrix cm, CPoint cp) {
        return overlay(cm, cp);
    }

    public CMatrix imblend(CMatrix cm, CPoint cp, float alpha) {
        return overlay(cm, cp);
    }

    /**
     * Matlab compatible command:Resize the matrix to desired width and height
     * values
     *
     * @param w:width
     * @param h:height
     * @return CMatrix //
     */
//    public CMatrix resize(int w, int h) {
//        return imresize(w, h);
//    }
    public CMatrix resize(int n) {
        float[][] d = FactoryMatrix.resize(array.toFloatMatrix(), n);
        setArray(d);
        return this;
    }

//    public CMatrix resize(CSize c) {
//        return imresize(c.width, c.height);
//    }
    /**
     * Matlab compatible command: rotate image with desired theta angle
     *
     * @param theta
     * @return CMatrix
     */
    public CMatrix imrotate(float theta) {
        if (image == null) {
            image = ImageProcess.pixelsToImageGray(array.toFloatMatrix());
        }
        image = ImageProcess.rotateImage(image, theta);
        setArray(ImageProcess.imageToPixelsFloat(image));
        return this;
    }

    /**
     * Matlab compatible command: rotate image around CPoint with desired theta
     * angle theta is not a radian type
     *
     * @param theta
     * @return CMatrix
     */
    public CMatrix imrotate(CPoint cp, float theta) {
        if (image == null) {
            image = ImageProcess.pixelsToImageGray(array.toFloatMatrix());
        }
        image = ImageProcess.rotateImage(image, cp, theta);
        setArray(ImageProcess.imageToPixelsFloat(image));
        return this;
    }

    /**
     * Extract ring projection features (size:width/2) prerequisites: image
     * should be square stepSize=1 by default
     *
     * @return 1 dimensional ring projection data with the length of
     * imagewidth/2
     */
    public CMatrix extractFeatureRingProjection() {
        return extractFeatureRingProjection(1);
    }

    /**
     * Extract ring projection features (size:width/2) prerequisites: image
     * should be square
     *
     * @param stepSize
     * @return 1 dimensional ring projection data
     */
    public CMatrix extractFeatureRingProjection(int stepSize) {
        image = ImageProcess.pixelsToImageGray(array.toIntMatrix());
        setArray(ImageProcess.imageToPixelsFloat(image));
        float[] d = FeatureExtractionRingProjection.getRingProjection(array.toFloatMatrix(), stepSize);
        float[][] m = new float[1][d.length];
        m[0] = d;
        setArray(m);
        array = array.transpose();
        return this;
    }

    public CMatrix extractFeatureLBP2D(boolean isRegular) {
        int[] d = FeatureExtractionLBP.getLBP(array.toIntMatrix(), isRegular);
        setArray(d);
        return this;
    }

    public CMatrix extractFeatureLBP1D(int N, boolean isRegular) {
        int[] d = FeatureExtractionLBP.getLBP(array.toFloatVector(), N, isRegular);
        setArray(d);
        return this;
    }

    public CMatrix readFile(String path) {
        float[][] d = FactoryUtils.readFromFile(path, ",");
        setArray(d);
        image = ImageProcess.pixelsToImageGray(d);
        return this;
    }

    public CMatrix readFile(String path, String token) {
        float[][] d = FactoryUtils.readFromFile(path, token);
        setArray(d);
        image = ImageProcess.pixelsToImageGray(d);
        return this;
    }

    /**
     * Matlab compatible command: read txt file which contains comma seperated
     * float matrix
     *
     * @param path:file path
     * @return CMatrix
     */
    public CMatrix importdata(String path) {
        return readFile(path);
    }

    /**
     * Matlab compatible command: read txt file which contains token seperated
     * float matrix
     *
     * @param path:file path
     * @param token: it can be space, comma or semicolon or any arbitrary string
     * value for separation
     * @return CMatrix
     */
    public CMatrix importdata(String path, String token) {
        return readFile(path, token);
    }

    /**
     * perform Canny Edge Detection operator recommended parameters 0.3f, 1.0f,
     * 2.5f, 3, false
     *
     * @param lowThreshold
     * @param highThreshold
     * @param gaussianKernelRadious
     * @param guassianKernelWidth
     * @param isContrastNormalized
     * @return
     */
    public CMatrix detectEdgeCanny(
            float lowThreshold,
            float highThreshold,
            float gaussianKernelRadious,
            int guassianKernelWidth,
            boolean isContrastNormalized) {

        image = ImageProcess.pixelsToImageGray(ImageProcess.imageToPixelsFloat(ImageProcess.edgeDetectionCanny(image, lowThreshold, highThreshold, gaussianKernelRadious, guassianKernelWidth, isContrastNormalized)));
        setArray(ImageProcess.imageToPixelsFloat(image));

        return this;
    }

    /**
     * perform Sobel Edge Detection operator
     *
     *
     * @return
     */
    public CMatrix edgeDetectionSobel(int thr) {
        SobelEdgeDetector sob = new SobelEdgeDetector(array.toFloatMatrix());
        setArray(sob.process(thr));
        image = ImageProcess.pixelsToImageGray(array.toFloatMatrix());
        return this;
    }

    /**
     * perform Canny Edge Detection operator recommended parameters 0.3f, 1.0f,
     * 2.5f, 3, false
     *
     * @return
     */
    public CMatrix edgeDetectionCanny() {
        image = ImageProcess.pixelsToImageGray(ImageProcess.imageToPixelsFloat(ImageProcess.edgeDetectionCanny(image, 0.3f, 1.0f, 2.5f, 3, false)));
        setArray(ImageProcess.imageToPixelsFloat(image));
        return this;
    }

    /**
     * perform Musa Edge Detection operator recommended parameters
     *
     * @param thr:threshold value
     * @return
     */
    public CMatrix edgeDetectionMusa(int thr) {
        setArray(ImageProcess.edgeDetectionMusa(array.toFloatMatrix(), thr));
        image = ImageProcess.pixelsToImageGray(array.toFloatMatrix());
        return this;
    }

    /**
     * binarize image based on otsu method
     *
     * @return
     */
    public CMatrix binarizeOtsu() {
        int thr = ImageProcess.getOtsuTresholdValue(image);
        image = ImageProcess.binarizeGrayScaleImage(array.toFloatMatrix(), thr);
        setArray(ImageProcess.imageToPixelsFloat(image));
        return this;
    }

    /**
     * draw a specified color line onto image from point1 to point 2
     *
     * @param r1
     * @param c1
     * @param r2
     * @param c2
     * @param color
     * @return
     */
    public CMatrix drawLine(int r1, int c1, int r2, int c2, int th, Color color) {
        if (image.getType() == BufferedImage.TYPE_BYTE_GRAY) {
            image = ImageProcess.drawLine(image, r1, c1, r2, c2, th, color);
            setArray(ImageProcess.imageToPixelsFloat(image));
        } else {
            image = ImageProcess.drawLine(image, r1, c1, r2, c2, th, color);
        }
        return this;
    }

    /**
     * draw a text string with the specified color onto image use imshow to
     * visualize
     *
     * @param msg
     * @param r
     * @param c
     * @param angle : should be Math.Pi unit
     * @param color
     * @return
     */
    public CMatrix drawString(String msg, int r, int c, float angle, Color color) {
        Graphics2D g2d = (Graphics2D) image.getGraphics();
        g2d.setColor(color);
        g2d.drawString(msg, c, r);
//        AffineTransform orig = g2d.getTransform();
//        g2d.rotate(angle);
//        g2d.drawString(msg, c, r);
//        g2d.setTransform(orig);

        return this;
    }

//    /**
//     * draw a specified color line onto image from point1 to point 2 use imshow
//     * to visualize
//     *
//     * @param p1
//     * @param p2
//     * @param color
//     * @return
//     */
//    public CMatrix drawLine(CPoint p1, CPoint p2,int th, Color color) {
//        return drawLine(p1.row, p1.column, p2.row, p2.column,th, color);
//    }
    /**
     * draw a specified color rectangle onto image from point1 to point 2 use
     * imshow to visualize
     *
     * @param r:row
     * @param c:column
     * @param w:width
     * @param h:height
     * @param thickness
     * @param color:Color.RED i.e.
     * @return
     */
    public CMatrix drawRect(int r, int c, int w, int h, int thickness, Color color) {
        if (image == null) {
            image = ImageProcess.pixelsToImageColor(array.toFloatMatrix());
        }
        image = ImageProcess.drawRectangle(image, r, c, w, h, thickness, color);
        setArray(ImageProcess.imageToPixelsFloat(image));
        return this;
    }

    /**
     * draw a specified color rectangle onto image from point1 to point 2 use
     * imshow to visualize
     *
     * @param rect:CRectangle
     * @param thickness:thickness
     * @param color:Color.RED i.e.
     * @return
     */
    public CMatrix drawRect(CRectangle rect, int thickness, Color color) {
        return drawRect(rect.row, rect.column, rect.width, rect.height, thickness, color);
    }

    /**
     * draw a specified color round rectangle onto image from point1 to point 2
     * use imshow to visualize
     *
     * @param r:row
     * @param c:column
     * @param w:width
     * @param h:height
     * @param color:Color.RED i.e.
     * @return
     */
    public CMatrix drawRoundRect(int r, int c, int w, int h, int aw, int ah, int thickness, Color color) {
        CMatrix ret = this.clone();

        ret.image = ImageProcess.drawRoundRectangle(ret.image, r, c, w, h, aw, ah, thickness, color);

        return ret;
    }

    /**
     * fill a specified color round rectangle onto image from point1 to point 2
     * use imshow to visualize
     *
     * @param r:row
     * @param c:column
     * @param w:width
     * @param h:height
     * @param color:Color.RED i.e.
     * @return
     */
    public CMatrix fillRoundRect(int r, int c, int w, int h, int aw, int ah, Color color) {
        CMatrix ret = this.clone();

        ret.image = ImageProcess.fillRoundRectangle(ret.image, r, c, w, h, aw, ah, color);

        return ret;
    }

    /**
     * draw a specified color round rectangle onto image from point1 to point 2
     * use imshow to visualize
     *
     * @param r:row
     * @param c:column
     * @param w:width
     * @param h:height
     * @param color:Color.RED i.e.
     * @return
     */
    public CMatrix draw3DRect(int r, int c, int w, int h, int aw, int ah, int thickness, Color color) {
        CMatrix ret = this.clone();

        ret.image = ImageProcess.draw3DRectangle(ret.image, r, c, w, h, thickness, color);

        return ret;
    }

    /**
     * fill a specified color round rectangle onto image from point1 to point 2
     * use imshow to visualize
     *
     * @param r:row
     * @param c:column
     * @param w:width
     * @param h:height
     * @param color:Color.RED i.e.
     * @return
     */
    public CMatrix fill3DRect(int r, int c, int w, int h, int aw, int ah, Color color) {
        CMatrix ret = this.clone();

        ret.image = ImageProcess.fill3DRectangle(ret.image, r, c, w, h, color);

        return ret;
    }

    /**
     * draw a specified color polygon onto image use imshow to visualize
     *
     * @return
     */
    public CMatrix drawPolygon(Polygon p, int thickness, Color color) {
        CMatrix ret = this.clone();

        ret.image = ImageProcess.drawPolygon(ret.image, p, thickness, color);

        return ret;
    }

    /**
     * fill a specified color round rectangle onto image from point1 to point 2
     * use imshow to visualize
     *
     * @param color:Color.RED i.e.
     * @return
     */
    public CMatrix fillPolygon(Polygon p, Color color) {
        CMatrix ret = this.clone();

        ret.image = ImageProcess.fillPolygon(ret.image, p, color);

        return ret;
    }

    /**
     * draw a specified color shape use imshow to visualize
     *
     * @param color:Color.RED i.e.
     * @return
     */
    public CMatrix drawShape(java.awt.Shape sh, int thickness, Color color) {
        CMatrix ret = this.clone();

        ret.image = ImageProcess.drawShape(ret.image, sh, thickness, color);

        return ret;
    }

    /**
     * fill a specified color shape use imshow to visualize
     *
     * @param color:Color.RED i.e.
     * @return
     */
    public CMatrix fillShape(java.awt.Shape sh, Color color) {
        CMatrix ret = this.clone();

        ret.image = ImageProcess.fillShape(ret.image, sh, color);

        return ret;
    }

    /**
     * draw a specified color arc use imshow to visualize
     *
     * @param r:row
     * @param c:column
     * @param w:width
     * @param h:height
     * @param color:Color.RED i.e.
     * @return
     */
    public CMatrix drawArc(int r, int c, int w, int h, int sa, int aa, int thickness, Color color) {
        CMatrix ret = this.clone();

        ret.image = ImageProcess.drawArc(ret.image, r, c, w, h, sa, aa, thickness, color);

        return ret;
    }

    /**
     * draw a specified color rectangle onto image from point1 to point 2 use
     * imshow to visualize
     *
     * @param r:row
     * @param c:column
     * @param w:width
     * @param h:height
     * @param color:Color.RED i.e.
     * @return
     */
    public CMatrix fillRect(int r, int c, int w, int h, Color color) {
        CMatrix ret = this.clone();

        ret.image = ImageProcess.fillRectangle(ret.image, r, c, w, h, color);

        return ret;
    }

    /**
     * draw a specified color rectangle onto image from point1 to point 2 use
     * imshow to visualize
     *
     * @param r:row
     * @param c:column
     * @param w:width
     * @param h:height
     * @param color:Color.RED i.e.
     * @return
     */
    public CMatrix drawOval(int r, int c, int w, int h, int thickness, Color color) {
        CMatrix ret = this.clone();

        ret.image = ImageProcess.drawOval(ret.image, r, c, w, h, thickness, color);

        return ret;
    }

    /**
     * draw a specified color rectangle onto image from point1 to point 2 use
     * imshow to visualize
     *
     * @param r:row
     * @param c:column
     * @param w:width
     * @param h:height
     * @param color:Color.RED i.e.
     * @return
     */
    public CMatrix fillOval(int r, int c, int w, int h, Color color) {
        CMatrix ret = this.clone();

        Graphics2D g2d = (Graphics2D) ret.image.getGraphics();
        g2d.setColor(color);
        g2d.fillOval(c, r, w, h);

        return ret;
    }

//    /**
//     * draw a specified color rectangle onto image from point1 to point 2 use
//     * imshow to visualize
//     *
//     * @param p1
//     * @param p2
//     * @param color
//     * @return
//     */
//    public CMatrix drawRect(CPoint p1, int w, int h,int th, Color color) {
//        return drawRect(p1.row, p1.column, w, h,th, color);
//    }
    /**
     * convert to original image type to desired type
     *
     * @param newType:BufferedImage types
     * @return
     */
    public CMatrix toNewColorSpace(int newType) {
        if (image == null) {
            image = ImageProcess.pixelsToImageGray(array.toIntMatrix());
        }
        image = ImageProcess.toNewColorSpace(image, newType);
        return this;
    }

    /**
     * Discrete Cosine Transform Note that width and height of the matrix or
     * image should be 8's power
     *
     * @return
     */
    public CMatrix transformDCT() {
        if (image == null) {
            image = ImageProcess.pixelsToImageGray(array.toFloatMatrix());
        }
        image = ImageProcess.DCT(image);
        setArray(ImageProcess.imageToPixelsFloat(image));
        return this;
    }

    /**
     * Matlab compatible command: Discrete Cosine Transform, Note that width and
     * height of the matrix or image should be 8's power
     *
     * @return CMatrix
     */
    public CMatrix dct() {
        return transformDCT();
    }

    /**
     * B. All the well known transfer/transform/filter functions should be here
     */
    /**
     * Medikal GÃ¶rÃ¼ntÃ¼lemedeki Computed Tomograpghy nin radon transferi matrisi
     * sinograph eÄŸrilerine dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r
     *
     * @param numberOfAngles
     * @param numberOfProjections
     * @return
     */
    public CMatrix transformRadonForward(int numberOfAngles, int numberOfProjections) {
        setArray(TransformRadon.forwardProjection(array.toFloatMatrix(), numberOfAngles, numberOfProjections));
        return this;
    }

    /**
     * Medikal GÃ¶rÃ¼ntÃ¼lemedeki Computed Tomograpghy nin radon transferinin tersi
     * iÅŸlemi sinograph eÄŸrilerinden asÄ±l gÃ¶rÃ¼ntÃ¼ye dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r
     *
     * @param imgSize
     * @return
     */
    public CMatrix transformRadonBackward(int imgSize) {
        setArray(TransformRadon.backwardProjection(array.toFloatMatrix(), imgSize));
        return this;
    }

    /**
     * calculates the fast fourier transform of the real signal. Only positive
     * frequencies are available.
     *
     * @return
     */
    public CMatrix transformFFT() {
        array = array.transpose();
        TransformFFT fft = new TransformFFT(getColumnNumber());
        float[][] f = fft.calculateFFTMagnitude(array.toFloatMatrix());
        setArray(f);
        array = array.transpose();
        return this;
    }

    /**
     * Matlab compatible calculates the fast fourier transform of the real
     * signal. Only positive frequencies are available.
     *
     * @return
     */
    public CMatrix fft() {
        return transformFFT();
    }

    /**
     * Matlab compatible command: values greater than threshold 't' are passed
     *
     * @param d:input matrix
     * @param t:threshold value
     * @return CMatrix
     */
    public CMatrix highPassFilter(float[][] d, int t) {
        setArray(ImageProcess.highPassFilter(d, t));
        return this;
    }

    /**
     * Matlab compatible command: values greater than threshold 't' are passed
     *
     * @param t:threshold value
     * @return CMatrix
     */
    public CMatrix highPassFilter(int t) {
        setArray(ImageProcess.highPassFilter(array.toFloatMatrix(), t));
        return this;
    }

    public float getRoiMean(float[][] d, CPoint[] p) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    public CMatrix thresholdOtsu() {
        return binarizeOtsu();
    }

    public CMatrix threshold(int t) {
        image = ImageProcess.binarizeGrayScaleImage(array.toFloatMatrix(), t);
        setArray(ImageProcess.imageToPixelsFloat(image));
        return this;
    }

    public CMatrix threshold(int t1, int t2) {
        image = ImageProcess.thresholdGray(image, t1, t2);
        setArray(ImageProcess.imageToPixelsFloat(image));
        return this;
    }

    public void holdOn() {
        hold_on = true;
    }

    public void holdOff() {
        hold_on = false;
    }

    public CPoint getSize() {
        return new CPoint(this.getRowNumber(), this.getColumnNumber());
    }

    public CSize getImageSize() {
        return new CSize(this.getColumnNumber(), this.getRowNumber());
    }

    public CMatrix serialize(String fileName) {
        try {
            FactoryUtils.serialize(this, fileName);
        } catch (IOException ex) {
            Logger.getLogger(CMatrix.class.getName()).log(Level.SEVERE, null, ex);
        }
        return this;
    }

    public CMatrix deSerialize(String fileName) {
        CMatrix cm = CMatrix.getInstance();
        try {
            cm = (CMatrix) FactoryUtils.deserialize(fileName);
        } catch (IOException ex) {
            Logger.getLogger(CMatrix.class.getName()).log(Level.SEVERE, null, ex);
        } catch (ClassNotFoundException ex) {
            Logger.getLogger(CMatrix.class.getName()).log(Level.SEVERE, null, ex);
        }
        return cm;
    }

    /**
     * Matlab compatible see code of imnoise in Matlab
     *
     * @return
     */
    public CMatrix imnoise() {
        setArray(FactoryUtils.addSaltAndPepperNoise(array.toFloatMatrix(), 0.1f));
        image = ImageProcess.pixelsToImageGray(array.toFloatMatrix());
        return this;
    }

    /**
     * Matlab compatible see code of imnoise in Matlab
     *
     * @param m
     * @param v
     * @return
     */
    public CMatrix imnoise(float m, float v) {
        setArray(FactoryUtils.addGaussianNoise(array.toFloatMatrix(), m, v));
        image = ImageProcess.pixelsToImageGray(array.toFloatMatrix());
        return this;
    }

    /**
     * split method separates CMatrix into nFolds disjoint subset according to
     * the specified dimension last subset generally greater and equal to the
     * previous subset if number of rows can not be separated equally.
     *
     * split metodu CMatrix matrisini kesiÅŸmesi olmayan nFold adet alt kÃ¼meye
     * ayÄ±rÄ±r en son alt kÃ¼menin eleman sayÄ±sÄ± eÄŸer ki tam bÃ¶lÃ¼nemiyorsa
     * genellikle Ã¶ncekilerden bÃ¼yÃ¼k eÅŸittir
     *
     * @param nFolds
     * @return array of CMatrix
     */
    public CMatrix[] split(int nFolds) {
        CMatrix randData = this.clone();

        CMatrix[] ret = new CMatrix[nFolds];
        int nRows = randData.getRowNumber();
        int nCols = randData.getColumnNumber();
        int delta = nRows / nFolds;
        for (int i = 0; i < nFolds - 1; i++) {
            ret[i] = randData.clone().cmd(i * delta + ":" + ((i + 1) * delta), ":").println((i + 1) + ".subset");
        }
        CMatrix cm = CMatrix.getInstance().zeros(1, nCols);
        for (int i = (nFolds - 1) * delta; i < nRows; i++) {
            CMatrix temp = randData.getRowMatrix(i).transpose();
            cm = cm.cat(2, temp);
        }
        cm = cm.deleteRow(0);
        ret[nFolds - 1] = cm;//.println((nFolds) + ".subset");
        return ret;
    }

    /**
     * splitTestAndTrain method separates CMatrix Test and Train set based on
     * the ntrain and ntest values. ratio ranges between 0 and 1 and takes
     * floating number. 4 , 1 means 0.75 75% is train and 25% is test. It
     * returns CMatrix[0] as train and CMatrix[1] as test sets.
     *
     * splitTestAndTrain komutu parametrede belirtilmiÅŸ ntrain ve ntest
     * deÄŸerlerinin oranÄ± reel sayÄ± (0..1) arasÄ±nda deÄŸiÅŸir. Verisetini test ve
     * train kÃ¼mesine ayÄ±rÄ±r. 4 , 1 girilmesi durumunda oran 0.75 olacaÄŸÄ±ndan,
     * %75 train iÃ§in , %25 test iÃ§in ayÄ±rÄ±r. Geriye CMatrix[0] train, ve
     * CMatrix[1] ise test set olarak gÃ¶nderir.
     *
     * @return array of CMatrix
     */
    public CMatrix[] splitTestAndTrain(int ntrain, int ntest) {
        CMatrix ds = this.clone();

        CMatrix[] ret = new CMatrix[2];
        float r = 1.0f * ntrain / (ntrain + ntest);
        int pos = (int) (ds.getRowNumber() * r);
        ret[0] = ds.cmd("0:" + pos, ":");
        ret[1] = ds.cmd(pos + ":end", ":");
        return ret;
    }

    /**
     * splitTestAndTrain method separates CMatrix Test and Train set based on
     * the ratio. ratio ranges between 0 and 1 and takes floating number. 0.75
     * means 75% is train and 25% is test. It returns CMatrix[0] as train and
     * CMatrix[1] as test sets.
     *
     * splitTestAndTrain komutu parametrede belirtilmiÅŸ reel sayÄ± (0..1)
     * oranÄ±nda verisetini test ve train kÃ¼mesine ayÄ±rÄ±r. 0.75 girilmesi
     * durumunda, %75 train iÃ§in , %25 test iÃ§in ayÄ±rÄ±r. Geriye CMatrix[0]
     * train, ve CMatrix[1] ise test set olarak gÃ¶nderir.
     *
     * @return array of CMatrix
     */
    public CMatrix[] splitTestAndTrain(float r) {
        CMatrix ds = this.clone();

        CMatrix[] ret = new CMatrix[2];
        int pos = (int) (ds.getRowNumber() * r);
        ret[0] = ds.cmd("0:" + pos, ":");
        ret[1] = ds.cmd(pos + ":end", ":");
        return ret;
    }

    /**
     * Exclude operates as setdiff method in Matlab it simply try to get rid off
     * values from the original matrix if matrix size is in accordance based on
     * rows or columns logic
     *
     * please see cvSets or crossValidationSets for further info
     *
     * @param cm
     * @param dimension : 1=exclude from rows, 2=exclude from columns
     * @return
     */
    public CMatrix exclude(CMatrix cm, int dimension) {
        CMatrix ret = this.clone();

        if (dimension == 1 && ret.getColumnNumber() != cm.getColumnNumber()) {
            System.out.println("column number must be equal");
            return ret;
        }
        if (dimension == 2 && ret.getRowNumber() != cm.getRowNumber()) {
            System.out.println("row number must be equal");
            return ret;
        }
        if (dimension == 1 && ret.getColumnNumber() == cm.getColumnNumber()) {
            float[][] d = FactoryMatrix.excludeRows(ret.array.toFloatMatrix(), cm.array.toFloatMatrix());
            ret.setArray(d);
        }
        if (dimension == 2 && ret.getRowNumber() == cm.getRowNumber()) {
            ret = ret.transpose().exclude(cm.transpose(), 1).transpose();
        }
        return ret;
    }

    /**
     * it splits the dataset into nFolds disjoint folds for test and remaining
     * as train sets. Hence, it holds 2D CMatrix array from which, first
     * dimensions train and second one is test
     *
     * @param nFolds
     * @return
     */
    public CMatrix[][] crossValidationSets(int nFolds) {
        CMatrix randData = this.clone();
        CMatrix[][] ret = new CMatrix[nFolds][2];
        int nRows = randData.getRowNumber();
        int nCols = randData.getColumnNumber();
        int delta = nRows / nFolds;
        for (int i = 0; i < nFolds - 1; i++) {
            if (i == 0) {
                ret[i][0] = randData.cmd(((i + 1) * delta) + ":end", ":");
            } else {
                ret[i][0] = randData.cmd("0:" + ((i * delta) - 1), ":").cat(2, randData.cmd(((i + 1) * delta) + ":end", ":"));
            }
            ret[i][1] = randData.cmd(i * delta + ":" + ((i + 1) * delta - 1), ":");//.println((i + 1) + ".subset");
        }
        CMatrix cm = CMatrix.getInstance().zeros(1, nCols);
        for (int i = (nFolds - 1) * delta; i < nRows; i++) {
            CMatrix temp = randData.getRowMatrix(i).transpose();
            cm = cm.cat(2, temp);
        }
        cm = cm.deleteRow(0);
        ret[nFolds - 1][1] = cm;
        ret[nFolds - 1][0] = randData.cmd("0:" + (((nFolds - 1) * delta) - 1), ":");
        return ret;
    }

    public float getMaxTotal() {
        return array.maxNumber().floatValue();
    }

    public float getMinTotal() {
        return array.minNumber().floatValue();
    }

    /**
     * converts matrix to 1 dimensional column vector it calls reshape command
     *
     * @return
     */
    public CMatrix toColumnVector() {
        CMatrix ret = this.clone();

        ret = ret.reshape(ret.getRowNumber() * ret.getColumnNumber(), 1);
        return ret;
    }

    /**
     * converts matrix to 1 dimensional row vector it calls reshape command
     *
     * @return
     */
    public CMatrix toRowVector() {
        CMatrix ret = this.clone();

        ret = ret.reshape(1, ret.getRowNumber() * ret.getColumnNumber());
        return ret;
    }

    public CMatrix jacobianApproximation(CMatrix A, CMatrix b, float tol) {
        CMatrix ret = this.clone();

        float error = 0;
        int n = b.getRowNumber();
        float s = 0;
        float xb = 0;
        float w = 1.2f;//relaxation number
        float[] x0 = new float[b.getRowNumber()];
        for (int t = 0; t < 2000; t++) {
            error = 0;
            for (int i = 0; i < n; i++) {
                s = 0;
                xb = x0[i];
                for (int j = 0; j < n; j++) {
                    if (i != j) {
                        s = s + A.getValue(i, j) * x0[j];
                    }

                }
                x0[i] = w * (b.array.toFloatVector()[i] - s) / (A.getValue(i, i)) + (1 - w) * x0[i];
                error += Math.abs(x0[i] - xb);
            }
            if (error / n < tol) {
                break;
            }
        }
        ret.setArray(x0);
        return ret;
    }

    public CMatrix jacobianApproximation(CMatrix b, float tol) {
        CMatrix A = this.clone();

        float error = 0;
        int n = b.getRowNumber();
        float s = 0;
        float xb = 0;
        float w = 1.2f;//relaxation number
        float[] x0 = new float[b.getRowNumber()];
        for (int t = 0; t < 2000; t++) {
            error = 0;
            for (int i = 0; i < n; i++) {
                s = 0;
                xb = x0[i];
                for (int j = 0; j < n; j++) {
                    if (i != j) {
                        s = s + A.getValue(i, j) * x0[j];
                    }

                }
                x0[i] = w * (b.array.toFloatVector()[i] - s) / (A.getValue(i, i)) + (1 - w) * x0[i];
                error += Math.abs(x0[i] - xb);
            }
            if (error / n < tol) {
                break;
            }
        }
        CMatrix ret = CMatrix.getInstance(x0);

        return ret;
    }

    /**
     * csvread is similar to the Matlab command and needs only file path of
     * desired excel file
     *
     * @param filePath : excel file path
     * @return CMatrix
     */
    public CMatrix csvread(String filePath) {
        CMatrix ret = this.clone();

        ret = CMatrix.getInstance(FactoryUtils.readCSV(filePath, ',', 0));
        return ret;
    }

    public CMatrix csvread(String filePath, char seperator, int header) {
        CMatrix ret = this.clone();

        ret = CMatrix.getInstance(FactoryUtils.readCSV(filePath, seperator, header));
        return ret;
    }

    /**
     * check matrix number of rows and columns it should be identical or equal
     * or same
     *
     * @param cm1 : checked matrix
     * @param cm2 : checked matrix
     * @return
     */
    public boolean isIdentical(CMatrix cm1, CMatrix cm2) {
        return cm1.getRowNumber() == cm2.getRowNumber() && cm1.getColumnNumber() == cm2.getColumnNumber();
    }

    /**
     * check matrix number of rows and columns it should be identical or equal
     * or same
     *
     * @param cm : checked matrix
     * @return boolean
     */
    public boolean isIdentical(CMatrix cm) {
        if (this.getRowNumber() == cm.getRowNumber() && this.getColumnNumber() == cm.getColumnNumber()) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * Matlab compatible padding around the matrix with value padding amount is
     * determined by nr and nc
     *
     * @param nr: padding number of rows (padding width as vertical)
     * @param nc: padding number of columns (padding width as horizontal)
     * @param val : padding value
     * @return CMatrix
     */
    public CMatrix padarray(int nr, int nc, float val) {
        return CMatrix.getInstance(FactoryMatrix.padarray(array.toFloatMatrix(), nr, nc, val));
    }

    public CMatrix detectFaces(String type) {
        CMatrix ret = this.clone();
        ret.setImage(ImageProcess.detectFaces(type, this.image));
        ret.setArray(ImageProcess.bufferedImageToArray2D(ret.getImage()));
        return ret;
    }

    public Rectangle[] getFaceLocations(String type) {
        Rectangle[] ret = ImageProcess.getFacesRectangles(type, this.image);
        return ret;
    }

    public CRectangle[] getFaceLocationsAsCRectangle(String type) {
        CRectangle[] ret = ImageProcess.getFacesRectanglesAsCRectangle(type, this.image);
        return ret;
    }

    public CMatrix imupdate() {
        if (image == null || image.getType() == BufferedImage.TYPE_BYTE_GRAY) {
            image = ImageProcess.pixelsToImageGray(array.toFloatMatrix());
        }
        return this;
    }

    public CMatrix updateImage() {
        return imupdate();
    }

    public CMatrix im2bw() {
        CMatrix cm = this.clone();

        if (cm.image.getType() != BufferedImage.TYPE_BYTE_GRAY) {
            cm = cm.rgb2gray();
        }
        cm = cm.binarizeOtsu();
        return cm;
    }

    public CMatrix im2bw(int thr) {
        CMatrix cm = this.clone();

        if (cm.image.getType() != BufferedImage.TYPE_BYTE_GRAY) {
            cm = cm.rgb2gray();
        }
        cm = cm.threshold(thr);

        return cm;
    }

    public CMatrix im2bw(int t1, int t2) {
        CMatrix cm = this.clone();

        if (cm.image.getType() != BufferedImage.TYPE_BYTE_GRAY) {
            cm = cm.rgb2gray();
        }
        cm = cm.imthreshold(t1, t2);

        return cm;
    }

    public CMatrix imbinarizeOtsu() {
        CMatrix cm = this.clone();

        if (cm.image.getType() != BufferedImage.TYPE_BYTE_GRAY) {
            cm = cm.rgb2gray();
        }
        cm = cm.binarizeOtsu();

        return cm;
    }

    /**
     * perform image binarization operation by using otsu thresholding
     *
     * @return
     */
    public CMatrix binarizeImage() {
        return im2bw();
    }

    public CMatrix binarizeImage(int thr) {
        return im2bw(thr);
    }

    private CMatrix imthreshold(int t1, int t2) {
        image = ImageProcess.adaptiveThreshold(array.toFloatMatrix(), t1, t2);
        setArray(ImageProcess.imageToPixelsFloat(image));
        return this;
    }

    public CMatrix overlay(CMatrix cm, float alpha) {
        image = ImageProcess.overlayImage(image, cm.image, alpha);
        return this;
    }

    public CMatrix overlay(BufferedImage bf, float alpha) {
        image = ImageProcess.overlayImage(image, bf, alpha);
        return this;
    }

    public CMatrix overlay(CMatrix cm, float alpha, CRectangle cr) {
        image = ImageProcess.overlayImage(image, cm.image, cr, 0);
        return this;
    }

    public CMatrix overlay(CMatrix cm, CPoint cp) {
        image = ImageProcess.overlayImage(image, cm.image, cp, 0);
        return this;
    }

    public CMatrix overlay(BufferedImage bf, CPoint cp) {
        image = ImageProcess.overlayImage(image, bf, cp, -1);
        return this;
    }

    public CMatrix overlay(CMatrix cm, CPoint cp, int backGroundColor) {
        image = ImageProcess.overlayImage(image, cm.image, cp, backGroundColor);
        return this;
    }

    public CMatrix im_cropBoundingBox() {
        image = ImageProcess.cropBoundingBox(image);
        setArray(ImageProcess.imageToPixelsFloat(image));
        return this;
    }

    public CMatrix reverseOrder() {
        setArray(FactoryMatrix.reverseOrder(array.toFloatMatrix()));
        return this;
    }

    public CMatrix bitPlaneMSB() {
        setArray(FactoryMatrix.bitPlaneMSB(array.toFloatMatrix()));
        image = ImageProcess.pixelsToImageGray(array.toFloatMatrix());
        return this;
    }

    public CMatrix bitPlane(int n) {
        setArray(FactoryMatrix.bitPlane(array.toFloatMatrix(), n));
        image = ImageProcess.pixelsToImageGray(array.toFloatMatrix());
        return this;
    }

    /**
     * for compliance with Matlab, native java developer can use bitPlane
     * command instead
     *
     * @param n
     * @return
     */
    public CMatrix bitget(int n) {
        return bitPlane(n);
    }

    public CMatrix imbitget(int n) {
        return bitPlane(n);
    }

    public CMatrix getImageBitSlicing(int n) {
        return bitPlane(n);
    }

    public CMatrix getBitPlane(int n) {
        return bitPlane(n);
    }

    public CMatrix im2QuantizationLevel(int n) {
        if (n >= 256 || n <= 0) {
            return this;
        }
        float t = 1;
        n = n - 1;
        if (n == 0) {
            t = 255;
        } else {
            t = 255.0f / n;
        }

        CMatrix ret = this.clone();

        ret = map(0, n).round().timesScalar(t);
        return ret;
    }

    public CMatrix equalizeHistogramMusa() {
        CMatrix ret = this.clone();

        ret = ret.getCDFData().map(0, 255).round();
        float[][] data = array.dup().toFloatMatrix();
        float[] ncdf = ret.array.toFloatVector();
        int val = 0;
        for (int i = 0; i < data.length; i++) {
            for (int j = 0; j < data[0].length; j++) {
                val = (int) data[i][j];
                data[i][j] = ncdf[val];
            }
        }
        ret.setArray(data);
        ret.setImage(ImageProcess.pixelsToImageGray(data));
        return ret;
    }

    public CMatrix histCumulative() {
        return getCDFData();
    }

    public CMatrix histeq() {
        return equalizeHistogram();
    }

    public CMatrix histeqMusa() {
        return equalizeHistogramMusa();
    }

    public CMatrix equalizeHistogram() {
        CMatrix ret = this.clone();

        ret.setImage(ImageProcess.equalizeHistogram(ret.image));
        return ret;
    }

    public CPoint getCenterOfGravity() {
        return ImageProcess.getCenterOfGravityGray(array.toFloatMatrix());
    }

    public CMatrix smoothMatrix() {
        setArray(FactoryMatrix.smoothColumns(array.toFloatMatrix(), 3));
        updateImage();
        return this;
    }

    public CMatrix smoothMatrix(int size) {
        setArray(FactoryMatrix.smoothColumns(array.toFloatMatrix(), size));
        updateImage();
        return this;
    }

    public CMatrix smoothMatrixTimes(int times) {
        CMatrix ret = this.clone();

        for (int i = 0; i < times; i++) {
            ret = ret.smoothMatrix();
        }
        return ret;
    }

    /**
     * param N:for N bit i.e:8 bit produces totally 256 LBP features
     */
    public CMatrix lbp1D(int N, boolean isRegular) {
        return getLBP1D(N, isRegular);
    }

    public CMatrix getLBP1D(int N, boolean isRegular) {
        int[][] lbp = FeatureExtractionLBP.getLBP(array.toFloatMatrix(), N, isRegular);
        setArray(lbp);
        return this;
    }

    /**
     * Fast Wavelet Transform Implementation
     *
     * @param type : write "haar" or "db2", "db3", "db4", "db5", "db6", "db7" in
     * a samller case
     * @return
     */
    public CMatrix fwt_1D_decompose(String type) {
        setArray(FactoryMatrix.fwt_1D_decompose(array.toFloatVector(), type));
        return this;
    }

    /**
     * Discrete Wavelet Transform Implementation
     *
     * @param type : write "haar" or "db2", "db3", "db4", "db5", "db6", "db7" in
     * a samller case
     * @return
     */
    public CMatrix dwt_1D_decompose(String type) {
        return fwt_1D_decompose(type);
    }

    /**
     * Discrete Wavelet Transform Implementation
     *
     * @param type : write "haar" or "db2", "db3", "db4", "db5", "db6", "db7" in
     * a samller case
     * @return
     */
    public CMatrix wavelet_1D_decompose(String type) {
        return fwt_1D_decompose(type);
    }

    /**
     * Discrete Wavelet Transform Implementation
     *
     * @param type : write "haar" or "db2", "db3", "db4", "db5", "db6", "db7" in
     * a samller case
     * @return
     */
    public CMatrix transformWavelet_1d_decompose(String type) {
        return fwt_1D_decompose(type);
    }

    /**
     * Fast Wavelet Transform Implementation
     *
     * @param type : write "haar" or "db2", "db3", "db4", "db5", "db6", "db7" in
     * a samller case
     * @param depth: write decomposition level
     * @return
     */
    public CMatrix fwt_forward(String type, int depth) {
        setArray(FactoryMatrix.fwt_1D_forward(array.toFloatVector(), type, depth));
        return this;
    }

    /**
     * Discrete Wavelet Transform Implementation
     *
     * @param type : write "haar" or "db2", "db3", "db4", "db5", "db6", "db7" in
     * a samller case
     * @param depth: write decomposition level
     * @return
     */
    public CMatrix dwt_forward(String type, int depth) {
        return fwt_forward(type, depth);
    }

    /**
     * Discrete Wavelet Transform Implementation
     *
     * @param type : write "haar" or "db2", "db3", "db4", "db5", "db6", "db7" in
     * a samller case
     * @param depth: write decomposition level
     * @return
     */
    public CMatrix wavelet_forward(String type, int depth) {
        return fwt_forward(type, depth);
    }

    /**
     * Discrete Wavelet Transform Implementation
     *
     * @param type : write "haar" or "db2", "db3", "db4", "db5", "db6", "db7" in
     * a samller case
     * @param depth: write decomposition level
     * @return
     */
    public CMatrix transformWavelet_forward(String type, int depth) {
        return fwt_forward(type, depth);
    }

    /**
     * Fast Wavelet Transform Implementation
     *
     * @param type : write "haar" or "db2", "db3", "db4", "db5", "db6", "db7" in
     * a samller case
     * @param depth: write decomposition level
     * @return
     */
    public CMatrix fwt_reverse(String type, int depth) {
        setArray(FactoryMatrix.fwt_1D_reverse(array.toFloatVector(), type, depth));
        return this;
    }

    /**
     * Discrete Wavelet Transform Implementation
     *
     * @param type : write "haar" or "db2", "db3", "db4", "db5", "db6", "db7" in
     * a samller case
     * @param depth: write decomposition level
     * @return
     */
    public CMatrix dwt_reverse(String type, int depth) {
        return fwt_reverse(type, depth);
    }

    /**
     * Discrete Wavelet Transform Implementation
     *
     * @param type : write "haar" or "db2", "db3", "db4", "db5", "db6", "db7" in
     * a samller case
     * @param depth: write decomposition level
     * @return
     */
    public CMatrix wavelet_reverse(String type, int depth) {
        return fwt_reverse(type, depth);
    }

    /**
     * Discrete Wavelet Transform Implementation
     *
     * @param type : write "haar" or "db2", "db3", "db4", "db5", "db6", "db7" in
     * a samller case
     * @param depth: write decomposition level
     * @return
     */
    public CMatrix transformWavelet_reverse(String type, int depth) {
        return fwt_reverse(type, depth);
    }

    /**
     * link (things) together in a chain or series according to rows
     *
     * @return
     */
    public CMatrix concatenateRows() {
        setArray(FactoryMatrix.concatenateRows(array.toFloatMatrix()));
        return this;
    }

    /**
     * link (things) together in a chain or series according to columns
     *
     * @return
     */
    public CMatrix concatenateColumns() {
        setArray(FactoryMatrix.concatenateColumns(array.toFloatMatrix()));
        return this;
    }

    public float[][][] getARGB() {
        if (image != null) {
            return ImageProcess.imageToPixelsColorDoubleFaster(image);
        } else {
            this.image = ImageProcess.pixelsToImageColor(array.toFloatMatrix());
            return ImageProcess.imageToPixelsColorDoubleFaster(image);
        }
    }

    public CMatrix argbToBufferedImage(float[][][] argb) {
        return fromARGB(argb);
    }

    public CMatrix fromARGB(float[][][] argb) {
        BufferedImage img = ImageProcess.pixelsToImageColorArgbFormat(argb);
        img = ImageProcess.convertToBufferedImageTypes(img, BufferedImage.TYPE_3BYTE_BGR);
        return new CMatrix(img);
    }

    public CMatrix fromARGB(CMatrix[] cms) {
        float[][][] argb = new float[4][][];
        for (int i = 0; i < cms.length; i++) {
            argb[i] = cms[i].array.toFloatMatrix();
        }
        BufferedImage img = ImageProcess.pixelsToImageColorArgbFormat(argb);
        return new CMatrix(img);
    }

    public CMatrix highPass(CMatrix cm) {
        float[][] d = FactoryMatrix.highPass(array.toFloatMatrix(), cm.array.toFloatMatrix());
        setArray(d);
        return this;
    }

    public CMatrix lowPass(CMatrix cm) {
        float[][] d = FactoryMatrix.lowPass(array.toFloatMatrix(), cm.array.toFloatMatrix());
        setArray(d);
        return this;
    }

    public CMatrix[] toARGB() {
        long t1 = FactoryUtils.tic();
        CMatrix[] ret = new CMatrix[4];
        float[][][] d = toFloatArray3D();
        t1 = FactoryUtils.toc("cost of to float array conversion:", t1);
        for (int i = 0; i < ret.length; i++) {
            ret[i] = new CMatrix(d[i]);
        }
        t1 = FactoryUtils.toc("cost of building new CMatrix:", t1);
        return ret;
    }

    /**
     * improved version of plot, based on javafx charts
     *
     * @param lst : column names
     * @return
     */
    public CMatrix setColumnNames(List<String> lst) {
        this.columnNames = lst;
        return this;
    }

    public List<String> getColumnNames() {
        return columnNames;
    }

    public List getClassLabels() {
        return classLabels;
    }

    public CMatrix setClassLabels(List classLabels) {
        this.classLabels = classLabels;
        return this;
    }

    /**
     * wait in milli seconds
     *
     * @param milli_second : milli second
     * @return
     */
    public CMatrix delay(int milli_second) {
        try {
            Thread.sleep(milli_second);
        } catch (InterruptedException ex) {
            Logger.getLogger(CMatrix.class.getName()).log(Level.SEVERE, null, ex);
        }
        return this;
    }

    public CMatrix setXData4FX(float[] d) {
        this.xData4FX = d;
        return this;
    }

    public float[] getXData4FX() {
        return xData4FX;
    }

    /**
     * sort matrix (column wised) along ascending order similar to the Matlab
     * sort function
     *
     * @return
     */
    public CMatrix sort() {
        setArray(Nd4j.sort(array, 0, true));
        return this;
    }

    /**
     * sort matrix (column wised) along ascending order similar to the Matlab
     * sort function
     *
     * @param dimension : sorting along which dimension; select "column" or
     * "row"
     * @return
     */
    public CMatrix sort(String dimension) {
        if (dimension.contains("row")) {
            setArray(Nd4j.sort(array, 0, true));
        } else if (dimension.contains("column")) {
            setArray(Nd4j.sort(array, 1, true));
        }
        return this;
    }

    /**
     * sort matrix dimension wised selected order similar to the Matlab please
     * choose appropriate String keywords below as it is. sort function
     *
     * @param dimension : sorting along which dimension; select "column" or
     * "row"
     * @param order : in an "ascend" or "descend" order select one of both
     * @return
     */
    public CMatrix sort(String dimension, String order) {
        if (dimension.contains("row")) {
            if (order.contains("asc")) {
                setArray(Nd4j.sort(array, 0, true));
            } else if (order.contains("asc")) {
                setArray(Nd4j.sort(array, 0, false));
            }
        } else if (dimension.contains("column")) {
            if (order.contains("asc")) {
                setArray(Nd4j.sort(array, 1, true));
            } else if (order.contains("asc")) {
                setArray(Nd4j.sort(array, 1, false));
            }
        }
        return this;
    }

//    public CMatrix catHorizontal(int dim, int... val) {
//        CMatrix ret = this.clone();
//        float[][] d = FactoryMatrix.catHorizontal(ret.array, val);
//        ret.setArray(d);
//        return ret;
//    }
//
//    public CMatrix catVertical(int dim, int... val) {
//        CMatrix ret = this.clone();
//        float[][] d = FactoryMatrix.catVertical(ret.array, val);
//        ret.setArray(d);
//        return ret;
//    }
    public CMatrix imerode() {
        CMatrix ret = this.clone();
        ret.setImage(ImageProcess.erode(ret.getImage()));
        return ret;
    }

    public CMatrix imdilate() {
        CMatrix ret = this.clone();
        ret.setImage(ImageProcess.dilate(ret.getImage()));
        return ret;
    }

    /**
     * Calculate Euclidean distance between two vectors
     *
     * @param cm
     * @return
     */
    public CMatrix euc(CMatrix cm) {
        if (!this.isIdentical(cm)) {
            System.err.println("Matrix dimension is not identical");
            return this;
        }
        CMatrix ret = this.clone();
        ret = ret.minus(cm).pow(2).sum().sqrt();
        return ret;
    }

    /**
     * Calculate Euclidean distance between two vectors
     *
     * @param cm1
     * @param cm2
     * @return
     */
    public CMatrix euc(CMatrix cm1, CMatrix cm2) {
        if (!cm1.isIdentical(cm2)) {
            System.err.println("Matrix dimension is not identical");
            return this;
        }
        CMatrix ret = cm1.minus(cm2).pow(2).sum().sqrt();
        return ret;
    }

    /**
     * Calculate column based Mean Square Error of two Matrices
     *
     * @param cm
     * @return
     */
    public CMatrix mse(CMatrix cm) {
        if (!this.isIdentical(cm)) {
            System.err.println("Matrix dimension is not identical");
            return this;
        }
        CMatrix ret = this.clone();
        ret = ret.minus(cm).pow(2).sum().sum();
        return ret;
    }

    /**
     * Calculate column based Mean Square Error of two Matrices
     *
     * @param cm1
     * @param cm2
     * @return
     */
    public CMatrix mse(CMatrix cm1, CMatrix cm2) {
        if (!cm1.isIdentical(cm2)) {
            System.err.println("Matrix dimension is not identical");
            return this;
        }
        CMatrix ret = cm1.minus(cm2).pow(2).sum().sum();
        return ret;
    }

    /**
     * Calculate column based Mean Square Error of two Matrices
     *
     * @param cm
     * @return
     */
    public CMatrix getMeanSquareError(CMatrix cm) {
        return mse(cm);
    }

    /**
     * Calculate column based Mean Square Error of two Matrices
     *
     * @param cm1
     * @param cm2
     * @return
     */
    public CMatrix getMeanSquareError(CMatrix cm1, CMatrix cm2) {
        return mse(cm1, cm2);
    }

    /**
     * Calculates column based Cosine Similarity between two matrix
     *
     * @param cm
     * @return
     */
    public CMatrix cosineSimilarity(CMatrix cm) {
        if (!this.isIdentical(cm)) {
            System.err.println("Matrix dimension is not identical");
            return this;
        }
        CMatrix ret = this.clone();
        float[] d = FactoryUtils.getCosineSimilarity(ret.transpose().array.toFloatMatrix(), cm.transpose().array.toFloatMatrix());
        ret.setArray(d);
        return ret;
    }

    /**
     * Replicate/Duplicate the Matrix n times along column
     *
     * @param cm: replicated matrix
     * @param n : n times
     * @return CMatrix
     */
    public CMatrix replicateColumn(CMatrix cm, int n) {
        CMatrix ret2 = cm.clone(this);
        for (int i = 0; i < n - 1; i++) {
            cm = cm.cat(1, ret2);
        }
        return cm;
    }

    /**
     * Replicate/Duplicate the Matrix n times along column
     *
     * @param n
     * @return
     */
    public CMatrix replicateColumn(int n) {
        CMatrix ret = this.clone();
        CMatrix ret2 = this.clone();
        for (int i = 0; i < n; i++) {
            ret = ret.cat(1, ret2);
        }
        return ret;
    }

    /**
     * Replicate/Duplicate the Matrix n times along column
     *
     * @param n
     * @return
     */
    public CMatrix duplicateColumn(int n) {
        return replicateColumn(n);
    }

    /**
     * Replicate/Duplicate the Matrix n times along row
     *
     * @param cm: replicated matrix
     * @param n : n times
     * @return CMatrix
     */
    public CMatrix replicateRow(CMatrix cm, int n) {
        CMatrix ret2 = cm.clone(this);
        for (int i = 0; i < n - 1; i++) {
            cm = cm.cat(2, ret2);
        }
        return cm;
    }

    /**
     * Replicate/Duplicate the Matrix n times along row
     *
     * @param n
     * @return
     */
    public CMatrix replicateRow(int n) {
        CMatrix ret = this.clone();
        CMatrix ret2 = this.clone();
        for (int i = 0; i < n; i++) {
            ret = ret.cat(2, ret2);
        }
        return ret;
    }

    /**
     * Replicate/Duplicate the Matrix n times along row
     *
     * @param n
     * @return
     */
    public CMatrix replicate(int n) {
        return replicateRow(n).replicateColumn(n);
    }

    /**
     * Replicate/Duplicate the Matrix n times along row
     *
     * @param nr
     * @param nc
     * @return
     */
    public CMatrix replicate(int nr, int nc) {
        return replicateRow(nr).replicateColumn(nc);
    }

    /**
     * Replicate/Duplicate the Matrix n times along row
     *
     * @param n
     * @return
     */
    public CMatrix duplicateRow(int n) {
        return replicateRow(n);
    }

    /**
     * similar to python make_blobs generate data set with a number of centers
     * of Gaussian distribution based on given n_samples and
     * n_features(dimension) class labels (centers) can be accessed via
     * getClassLabel method columns are n_features rows are n_samples hint: you
     * can best visualize the dataset by using scatter method
     *
     * @param n_samples
     * @param n_features
     * @param centers
     * @return
     */
    public CMatrix make_blobs(int n_samples, int n_features, int centers) {
        return make_blobs(n_samples, n_features, centers, 100, 5);
    }

    public List getClassLabelValues() {
        return classLabelValues;
    }

    public CMatrix setClassLabelValues(List classLabels) {
        this.classLabelValues = classLabels;
        return this;
    }

    public List getClassLabelNames() {
        return classLabelNames;
    }

    public CMatrix setClassLabelNames(List classLabelNames) {
        this.classLabelNames = classLabelNames;
        return this;
    }

    /**
     * similar to python; make_blobs generate data set with a number of centers
     * of Gaussian distribution based on given n_samples and
     * n_features(dimension) class labels (centers) can be accessed via
     * getClassLabel method columns are n_features rows are n_samples hint: you
     * can best visualize the dataset by using scatter method
     *
     * @param n_samples
     * @param n_features
     * @param n_groups
     * @param mean_scale
     * @param var_scale
     * @return
     */
    public CMatrix make_blobs(int n_samples, int n_features, int n_groups, int mean_scale, int var_scale) {
        float[][] f = FactoryMatrix.make_blobs(n_samples, n_features, n_groups, mean_scale, var_scale, random);
        setArray(f);
        float[] cl = FactoryMatrix.getLastColumn(f);
        setClassLabelValues(Arrays.asList(cl));
        String[] gr_names = new String[n_groups];
        for (int i = 0; i < n_groups; i++) {
            gr_names[0] = "group " + (i + 1);
        }
        setClassLabelNames(Arrays.asList(gr_names));
        return this;
    }

//    public CMatrix setArray(float[][] f) {
//        array = f;
//        return this;
//    }
    /**
     * set SecureRandom seed in order to guarantee the same results for each
     * draw
     *
     * @param n
     * @return
     */
    public CMatrix random_seed(int n) {
        random = new SecureRandom();
        random.setSeed(n);
        return this;
    }

    /**
     * set SecureRandom seed in order to guarantee the same results for each
     * draw
     *
     * @param n
     * @return
     */
    public CMatrix random_seed(Object n) {
        random = new SecureRandom();
        return this;
    }

    /**
     * set SecureRandom seed in order to guarantee the same results for each
     * draw
     *
     * @param n
     * @return
     */
    public CMatrix setRandomSeed(int n) {
        return random_seed(n);
    }

    /**
     * set SecureRandom seed in order to guarantee the same results for each
     * draw
     *
     * @param n
     * @return
     */
    public CMatrix setRandomSeed(Object n) {
        return random_seed(n);
    }

    /**
     * select n random sample from the matrix mxn, if mxn is normal matrix it
     * selects random n rows, if mxn is column vector it selects random n rows,
     * if mxn is row vector it selects random n column
     *
     * @param n
     * @return
     */
    public CMatrix random_sample(int n) {
        int nr = getRowNumber();
        int nc = getColumnNumber();
        int[] index = FactoryMatrix.rand(n, nr, random);
        float[][] f = array.toFloatMatrix();
        if (nr > 1 && nc >= 1) {
            float[][] d = new float[n][nc];
            for (int i = 0; i < n; i++) {
                d[i] = f[index[i]];
            }
            setArray(d);
        } else if (nr == 1) {
            float[] d = new float[n];
            float[] ref = array.toFloatVector();
            for (int i = 0; i < n; i++) {
                d[i] = ref[index[i]];
            }
            setArray(d);
        }
        return this;
    }

    /**
     * generate a kernel of Laplacian of Gaussian so called Mexican Hat as 2D
     * LoG(x,y) = [(x^2+y^2-2*Sig^2)/Sig^4]*e^(-(x^2+y^2)/(2*Sig^2))
     *
     * @param sigma : standard deviation
     * @return CMatrix
     */
    public CMatrix mexicanHat2D(float sigma) {
        CMatrix ret = this.clone();
        int nr = ret.getRowNumber();
        int nc = ret.getColumnNumber();
        int mid = nr / 2;
        CMatrix cmx = CMatrix.getInstance().linspace(-mid, mid, nr).replicateColumn(nc).transpose();//.dump();
        CMatrix cmy = cmx.transpose();//.dump();
        float std2 = sigma * sigma;
        float std4 = std2 * std2;
        CMatrix arg = cmx.multiplyElement(cmx).add(cmy.multiplyElement(cmy)).multiplyScalar(-1).divideScalar(2 * std2);
        CMatrix h = arg.exp();
        float sumh = h.sumTotal();
        if (sumh != 0) {
            h = h.divideScalar(sumh);
        }
        CMatrix arg2 = cmx.multiplyElement(cmx).add(cmy.multiplyElement(cmy)).minusScalar(2 * std2).divideScalar(std4);
        CMatrix h1 = h.multiplyElement(arg2);
        h = h1.minusScalar(h1.sumTotal() / (ret.getMatrixVolume()));

        return h;
    }

    public CMatrix mexicanHat1D(float sigma) {
        CMatrix ret = this.clone();
        ret = ret.pow(2).timesScalar(-0.5f).exp().multiplyElement(ret.pow(2).timesScalar(sigma).minusFromScalar(1)).timesScalar(2.0f / (float) (Math.sqrt(3) * Math.pow(Math.PI, 0.25)));
        return ret;
    }

    public float getMatrixVolume() {
        return this.getRowNumber() * this.getColumnNumber();
    }

    /**
     * generate mesh grid matrix along x axes it is used for applying 2D
     * functions on the plane in a loop-less manner resembles to the Matlab
     * meshgrid command
     *
     * @param from:initial point
     * @param to:end point
     * @return CMatrix
     */
    public CMatrix meshGridX(float from, float to) {
        setArray(FactoryMatrix.meshGridX(array.toFloatMatrix(), from, to));
        return this;
    }

    /**
     * generate mesh grid matrix along x axes in default it is used for applying
     * 2D functions on the plane in a loop-less manner resembles to the Matlab
     * meshgrid command
     *
     * @param from:initial point
     * @param to:end point
     * @return CMatrix
     */
    public CMatrix meshGrid(float from, float to) {
        return meshGridX(from, to);
    }

    /**
     * generate mesh grid matrix along x axes yields square matrix of numberOf x
     * numberOf it is used for applying 2D functions on the plane in a loop-less
     * manner resembles to the Matlab meshgrid command
     *
     * @param from:initial point
     * @param to:end point
     * @param numberOf:# of elements
     * @return CMatrix
     */
    public CMatrix meshGridX(float from, float to, int numberOf) {
        setArray(FactoryMatrix.meshGridX(from, to, numberOf));
        return this;
    }

    /**
     * generate mesh grid matrix along x axes in default yields square matrix of
     * numberOf x numberOf it is used for applying 2D functions on the plane in
     * a loop-less manner resembles to the Matlab meshgrid command
     *
     * @param from:initial point
     * @param to:end point
     * @param numberOf:# of elements
     * @return CMatrix
     */
    public CMatrix meshGrid(float from, float to, int numberOf) {
        return meshGridX(from, to, numberOf);
    }

    /**
     * generate mesh grid matrix along y axes it is used for applying 2D
     * functions on the plane in a loop-less manner resembles to the Matlab
     * meshgrid command
     *
     * @param from:initial point
     * @param to:end point
     * @return CMatrix
     */
    public CMatrix meshGridY(float from, float to) {
        setArray(FactoryMatrix.meshGridY(array.toFloatMatrix(), from, to));
        return this;
    }

    /**
     * generate mesh grid matrix along y axes yields square matrix of numberOf x
     * numberOf it is used for applying 2D functions on the plane in a loop-less
     * manner resembles to the Matlab meshgrid command
     *
     * @param from:initial point
     * @param to:end point
     * @param numberOf:# of elements
     * @return CMatrix
     */
    public CMatrix meshGridY(float from, float to, int numberOf) {
        setArray(FactoryMatrix.meshGridY(from, to, numberOf));
        return this;
    }

    public CMatrix meshGridIterateForward() {
        setArray(FactoryMatrix.meshGridIterateForward(array.toFloatMatrix()));
        return this;
    }

    public CMatrix inverseLog() {
        setArray(FactoryMatrix.inverseLog(array.toFloatMatrix()));
        return this;
    }

    public CMatrix inversePower(float x) {
        setArray(FactoryMatrix.inversePower(x, array.toFloatMatrix()));
        return this;
    }

    public CMatrix powerByScalar(float x) {
        return inversePower(x);
    }

    public CMatrix imWeightCenter(boolean isShow) {
        CMatrix ret = this.clone();
        CPoint cp = ImageProcess.getCenterOfGravityColor(ret.image, isShow);
        float[] d = new float[2];
        d[0] = cp.row;
        d[1] = cp.column;
        ret.setArray(d);
        return ret;
    }

    public CMatrix applyFunction(CMatrix f) {
        CMatrix ret = this.clone();
        ret = ret.rgb2gray();
        setArray(FactoryMatrix.applyFunction(array.toFloatMatrix(), f.array.toFloatVector()));
        image = ImageProcess.pixelsToImageGray(array.toFloatMatrix());
        return ret;
    }

    /**
     * compatible with Matlab's heatmap function try to colorize the matrix as
     * cells from blue to red in default or user can give the color range or
     * user can specify the center point (value) in the matrix and remaining
     * cells are colored around this point
     *
     * @return
     */
    public CMatrix heatmap() {
        if (!hold_on) {
            frameHeatMap = new FrameHeatMap(this);
        } else {
            if (frameHeatMap == null) {
                frameHeatMap = new FrameHeatMap(this);
            }
            frameHeatMap.setMatrix(this);
        }
        frameHeatMap.setVisible(true);
        return this;
    }

    /**
     * compatible with Matlab's heatmap function try to colorize the matrix as
     * cells from blue to red in default or user can give the color range or
     * user can specify the center point (value) in the matrix and remaining
     * cells are colored around this point
     *
     * @param showValue : write the value of the cell et the center
     * @return
     */
    public CMatrix heatmap(boolean showValue) {
        if (!hold_on) {
            frameHeatMap = new FrameHeatMap(this);
        } else {
            if (frameHeatMap == null) {
                frameHeatMap = new FrameHeatMap(this);
            }
            frameHeatMap.setMatrix(this);
        }
        frameHeatMap.setVisible(true);
        return this;
    }

    /**
     * compatible with Matlab's heatmap function try to colorize the matrix
     * around the center color
     *
     * @param centerColor cells are colored around this color
     * @return original CMatrix
     */
    public CMatrix heatmap(Color centerColor) {
        if (!hold_on) {
            frameHeatMap = new FrameHeatMap(this);
        } else {
            if (frameHeatMap == null) {
                frameHeatMap = new FrameHeatMap(this);
            }
            frameHeatMap.setMatrix(this);
        }
        frameHeatMap.setCenterColor(centerColor);
        frameHeatMap.setVisible(true);
        return this;
    }

    /**
     * compatible with Matlab's heatmap function try to colorize the matrix
     * around center color
     *
     * @param centerColor cells are colored around this color
     * @param width :width of the frame
     * @param height:height of the frame
     * @return original CMatrix
     */
    public CMatrix heatmap(Color centerColor, int width, int height) {
        if (!hold_on) {
            frameHeatMap = new FrameHeatMap(this, width, height);
        } else {
            if (frameHeatMap == null) {
                frameHeatMap = new FrameHeatMap(this, width, height);
            }
            frameHeatMap.setMatrix(this);
        }
        frameHeatMap.setCenterColor(centerColor);
        frameHeatMap.setVisible(true);
        return this;
    }

    /**
     * compatible with Matlab's heatmap function try to colorize the matrix
     * around center color
     *
     * @param centerColor cells are colored around this color
     * @param width :width of the frame
     * @param height:height of the frame
     * @param showCellEdge : cell's edge visible or not
     * @return original CMatrix
     */
    public CMatrix heatmap(Color centerColor, int width, int height, boolean showCellEdge) {
        if (!hold_on) {
            frameHeatMap = new FrameHeatMap(this, width, height, showCellEdge);
        } else {
            if (frameHeatMap == null) {
                frameHeatMap = new FrameHeatMap(this, width, height, showCellEdge);
            }
            frameHeatMap.setMatrix(this);
        }
        frameHeatMap.setCenterColor(centerColor);
        frameHeatMap.setVisible(true);
        return this;
    }

    /**
     * compatible with Matlab's heatmap function try to colorize the matrix
     * around center color
     *
     * @param centerColor cells are colored around this color
     * @param width :width of the frame
     * @param height:height of the frame
     * @param showCellEdge : cell's edge visible or not
     * @return original CMatrix
     */
    public CMatrix heatmap(Color centerColor, int width, int height, boolean showCellEdge, boolean showValue) {
        if (!hold_on) {
            frameHeatMap = new FrameHeatMap(this, width, height, showCellEdge, showValue);
        } else {
            if (frameHeatMap == null) {
                frameHeatMap = new FrameHeatMap(this, width, height, showCellEdge, showValue);
            }
            frameHeatMap.setMatrix(this);
        }
        frameHeatMap.setCenterColor(centerColor);
        frameHeatMap.setVisible(true);
        return this;
    }

    /**
     * compatible with Matlab's heatmap function try to colorize the matrix as
     * cells from blue to red in default or user can give the color range or
     * user can specify the center point (value) in the matrix and remaining
     * cells are colored around this point
     *
     * @param fromColor start color
     * @param centerColor center color
     * @param toColor final color
     * @return
     */
    public CMatrix heatmap(Color fromColor, Color centerColor, Color toColor) {
        if (!hold_on) {
            frameHeatMap = new FrameHeatMap(this);
        } else {
            if (frameHeatMap == null) {
                frameHeatMap = new FrameHeatMap(this);
            }
            frameHeatMap.setMatrix(this);
        }
        frameHeatMap.setFromColor(fromColor);
        frameHeatMap.setCenterColor(centerColor);
        frameHeatMap.setToColor(toColor);
        frameHeatMap.setVisible(true);
        return this;
    }

    public CMatrix addClassLabel(String scl) {
        float cl = Float.parseFloat(scl);
        setArray(FactoryMatrix.addClassLabel(array.toFloatMatrix(), cl));
        return this;
    }

    /**
     * perlin noise generator with scale equals to 0.1 by default
     *
     * @return
     */
    public CMatrix perlinNoise() {
        setArray(FactoryMatrix.perlinNoise(array.toFloatMatrix()));
        name = this.name + "|perlinNoise";
        return this;
    }

    /**
     * perlin noise generator with scale 0.01 to 10
     *
     * @param scale 0.01 to 10 hint: you should decrease scale if your matrix
     * become larger
     * @return
     */
    public CMatrix perlinNoise(float scale) {
        setArray(FactoryMatrix.perlinNoise(array.toFloatMatrix(), scale));
        name = this.name + "|perlinNoise";
        return this;
    }

    /**
     * Convolution operation
     *
     * @param kernel : kernel should be smaller than the original matrix
     * @return cloned CMatrix object
     */
    public CMatrix convolve(CMatrix kernel) {
        if (kernel.getRowNumber() != kernel.getColumnNumber()
                || kernel.getRowNumber() % 2 == 0
                || kernel.getColumnNumber() % 2 == 0
                || kernel.getRowNumber() >= this.getRowNumber()
                || kernel.getColumnNumber() >= this.getColumnNumber()) {
            System.err.println("kernel mismatch");
            return this;
        }
        name = this.name + "|convolve";
        setArray(FactoryMatrix.convolve(array.toFloatMatrix(), kernel.array.toFloatMatrix()));
        return this;
    }

    /**
     * Convolution operation with LBP
     *
     * @param size : 3x3 has size 3, 5x5 kernel matrix has size 5 etc.
     * @return cloned CMatrix object
     */
    public CMatrix convolveLBP(int size) {
        name = this.name + "|convolve LBP";
        setArray(FactoryMatrix.convolveLBP(array.toFloatMatrix(), size));
        return this;
    }

//    public CDL switchToDeepLearning() {
//        return CDL.getInstance(this);
//    }
    public CMatrix distinct() {
        double[] d = FactoryUtils.toDoubleArray1D(array.toFloatMatrix());
        d = Arrays.stream(d).distinct().toArray();
        setArray(d);
        return this;
    }

    public CMatrix bruteForceAttack(char[] pool, String pass, boolean isPrint) {
        long t = FactoryUtils.tic();
        BruteForce bf = new BruteForce(pool, 1);
        String newPass = bf.toString();
        while (true) {
            if (newPass.equals(pass)) {
                System.out.println("Password Found: " + newPass);
                break;
            }
            newPass = bf.toString();
            if (isPrint) {
                System.out.println("" + newPass);
            }
            bf.increment();
        }
        FactoryUtils.toc(t);
        return this;
    }

    public CMatrix shufflePixelImage() {
        int[] indexes = new int[array.rows() * array.columns()];
        setArray(FactoryMatrix.shuffleRowsAndColumns(array.toFloatMatrix(), indexes));
        shuffleIndexes = indexes;
        return this;
    }

    public CMatrix deShufllePixelImage() {
        setArray(FactoryMatrix.deShuffleRowsAndColumns(array.toFloatMatrix(), shuffleIndexes));
        return this;
    }

    /**
     * produce diagonal matrix based on the sequence provided in parameter i.e:
     * n=5 means 0:5 --> 0,1,2,3,4
     *
     * @param n
     * @return
     */
    public CMatrix diag(int n) {
        CMatrix ret = range(0, n).replicateColumn(n).multiplyElement(CMatrix.getInstance().eye(n));
        return ret;
    }

    /**
     * produce diagonal matrix based on the sequence provided as String command
     * ie: "-12:15:1.44"
     *
     * @param s
     * @return
     */
    public CMatrix diag(String s) {
        if (!s.contains(":")) {
            System.out.println("command should contain : range");
            return this;
        }
        float[] p = FactoryUtils.resolveParamForRange(s);
        CMatrix ret = range(p).replicateColumn(p.length).multiplyElement(CMatrix.getInstance().eye(p.length));
        return ret;
    }

    /**
     * produce diagonal matrix based on the sequence provided as 1D array
     *
     * @param p
     * @return
     */
    public CMatrix diag(float[] p) {
        CMatrix ret = range(p).replicateColumn(p.length).multiplyElement(CMatrix.getInstance().eye(p.length));
        return ret;
    }

    /**
     * give info about current matrix size (number of rows;number of columns)
     *
     * @return
     */
    public CMatrix shape() {
        System.out.println("Matrix Shape = " + array.shapeInfoToString());
        //System.out.println("Matrix Shape:[" + this.getRowNumber() + "," + this.getColumnNumber() + "]");
        return this;
    }

    /**
     * give info about given matrix size (number of rows;number of columns)
     *
     * @param cm
     * @return
     */
    public CMatrix shape(CMatrix cm) {
        System.out.println("Matrix Shape = " + cm.array.shapeInfoToString());
        //System.out.println("Matrix Shape:[" + cm.getRowNumber() + "," + cm.getColumnNumber() + "]");
        return this;
    }

    /**
     * is given matrix is Vector or not
     *
     * @param cm
     * @return
     */
    public boolean isVector(CMatrix cm) {
        if (cm.getRowNumber() == 1 || cm.getColumnNumber() == 1) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * is current matrix is Vector or not
     *
     * @param cm
     * @return
     */
    public boolean isVector() {
        if (this.getRowNumber() == 1 || this.getColumnNumber() == 1) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * produce diagonal matrix provided that given matrix is vector of range
     *
     * @param cm
     * @return
     */
    public CMatrix diag(CMatrix cm) {
        if (!cm.isVector(cm)) {
            System.out.println("input is not a vector or nx1 or 1xn matrix");
            return this;
        }
        float[] p = cm.getArray1Dfloat();
        CMatrix ret = range(p).replicateColumn(p.length - 1).multiplyElement(CMatrix.getInstance().eye(p.length));
        return ret;
    }

    /**
     * negate all elements of the current matrix
     *
     * @return
     */
    public CMatrix negate() {
        return this.multiplyScalar(-1);
    }

    /**
     * negate all given indices in the current matrix.
     *
     * @param indices
     * @return
     */
    public CMatrix negate(CMatrix indices) {
        array = array.mul(-1);
        return this;
    }

    /**
     * negate all given indices in the given matrix.
     *
     * @param indices
     * @return
     */
    public CMatrix negate(CMatrix cm, CMatrix indices) {
        CMatrix ret = cm.clone(cm);
        float[][] d = FactoryMatrix.clone(ret.array.toFloatMatrix());
        float[] index = indices.getArray1Dfloat();
        float[] d2 = FactoryUtils.toFloatArray1D(d);
        for (int i = 0; i < index.length; i++) {
            d2[(int) index[i]] = -d2[(int) index[i]];
        }
        ret.setArray(d2).reshape(d.length, d[0].length);
        return ret;
    }

    /**
     * truncate all the elements of the current matrix from float to integer
     *
     * @return
     */
    public CMatrix trunc() {
        float[][] d = array.toFloatMatrix();
        int[][] d2 = FactoryUtils.trunc(d);
        setArray(d2);
        return this;
    }

    /**
     * truncate all the elements of the given matrix from float to integer
     *
     * @param cm
     * @return
     */
    public CMatrix trunc(CMatrix cm) {
        float[][] d = cm.array.toFloatMatrix();
        int[][] d2 = FactoryUtils.trunc(d);
        cm.setArray(d2);
        return cm;
    }

    /**
     * apply Math.ceil to the all elements of the current matrix
     *
     * @return
     */
    public CMatrix ceil() {
        array = Transforms.ceil(array);
        return this;
    }

    /**
     * apply Math.ceil to the all elements of the given matrix
     *
     * @param cm
     * @return
     */
    public CMatrix ceil(CMatrix cm) {
        cm.array = Transforms.ceil(cm.array);
        return cm;
    }

    /**
     * apply Math.floor to the all elements of the current matrix
     *
     * @return
     */
    public CMatrix floor() {
        array = Transforms.floor(array);
        return this;
    }

    /**
     * apply Math.ceil to the all elements of the given matrix
     *
     * @param cm
     * @return
     */
    public CMatrix floor(CMatrix cm) {
        cm.array = Transforms.floor(cm.array);
        return cm;
    }

    public CMatrix startWebSocket(InterfaceCallBack icb) {
        FactorySocket.startJavaWebSocketServer(icb);
        return this;
    }

    public CMatrix startWebSocket(int port, InterfaceCallBack icb) {
        FactorySocket.startJavaWebSocketServer(FactoryUtils.getLocalIP(), 8887, icb);
        return this;
    }

    public CMatrix startWebSocket(String ip, int port, InterfaceCallBack icb) {
        FactorySocket.startJavaWebSocketServer(ip, port, icb);
        return this;
    }

    Connection db_con = null;

    public CMatrix connectDB(String dbName, String dbUser, String password) {
        db_con = new FactoryDataBase().connectDB("127.0.0.1", dbName, dbUser, password);
        if (db_con != null) {
            System.out.println("Database connection was established successfully");
        }
        return this;
    }

    public CMatrix connectDB(String ip, String dbName, String dbUser, String password) {
        db_con = new FactoryDataBase().connectDB(ip, dbName, dbUser, password);
        if (db_con != null) {
            System.out.println("Database connection was established successfully");
        }
        return this;
    }

    public CMatrix closeDB() {
        if (db_con != null) {
            try {
                db_con.close();
            } catch (SQLException ex) {
                Logger.getLogger(CMatrix.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
        return this;
    }

    public CMatrix executeSQL(String sql, CallBackDataBase callBackDataBase) {
        if (db_con == null) {
            System.out.println("Database connection was crushed try to connect database first");
            return this;
        }
        FactoryDataBase.getResultSet(sql, callBackDataBase);
        return this;
    }

    public String currentDirectory() {
        return FactoryUtils.getDefaultDirectory();
    }

    public CMatrix setModelForInferenceDJL(EnumOperatingSystem OS, EnumEngine engine, String modelPath, InterfaceCallBack callBackFunction) {
        if (engine == EnumEngine.MXNET) {
            if (!modelPath.contains("zip")) {
                String base_dir = new File(modelPath).getParent();
                String[] rows = FactoryUtils.readFile(base_dir + "/model_info.txt").split("\n");
                this.NUM_CHANNEL = Integer.parseInt(rows[0].split("=")[1]);
                this.IMAGE_WIDTH = Integer.parseInt(rows[1].split("=")[1]);
                this.IMAGE_HEIGHT = Integer.parseInt(rows[2].split("=")[1]);
                this.NUM_OUTPUT = Integer.parseInt(rows[3].split("=")[1]);
                this.BLOCK_TYPE = Integer.parseInt(rows[4].split("=")[1]);
                if (BLOCK_TYPE == TBlockType.MLP) {
                    String s = rows[5].split("=")[1].replace("[", "").replace("]", "").trim();
                    String[] ss = s.split(",");
                    int n = ss.length;
                    int[] hidden = new int[n];
                    for (int i = 0; i < n; i++) {
                        hidden[i] = Integer.parseInt(ss[i].trim());
                    }
                    Block block = FactoryDJL.getMLPBlock(NUM_CHANNEL, IMAGE_WIDTH, IMAGE_HEIGHT, NUM_OUTPUT, hidden);
                    model = FactoryDJL.getModelForInference(modelPath, block);
                } else if (BLOCK_TYPE == TBlockType.ResNetV50) {
                    String s = rows[6].split("=")[1];
                    int n = Integer.parseInt(s);
                    Block block = FactoryDJL.getResNetBlock(NUM_CHANNEL, IMAGE_WIDTH, IMAGE_HEIGHT, NUM_OUTPUT, n);
                    model = FactoryDJL.getModelForInference(modelPath, block);
                }

                translator = ImageClassificationTranslator.builder()
                        .addTransform(new Resize(IMAGE_WIDTH, IMAGE_HEIGHT))
                        .addTransform(new ToTensor())
                        .optApplySoftmax(true)
                        .build();
                predictor = model.newPredictor(translator);
            } else {
                // load model
                Criteria<Image, Classifications> criteria;
                try {
                    translator = ImageClassificationTranslator.builder()
                            .addTransform(new Resize(224, 224))
                            .addTransform(new ToTensor()) // HWC -> CHW div(255)
                            .addTransform(
                                    new Normalize(
                                            new float[]{0.5f, 0.5f, 0.5f},
                                            new float[]{1.0f, 1.0f, 1.0f}))
                            .addTransform(nd -> nd.flip(0)) // RGB -> GBR
                            .build();
                    criteria = Criteria.builder()
                            .optApplication(Application.CV.IMAGE_CLASSIFICATION)
                            .setTypes(Image.class, Classifications.class)
                            .optEngine("PaddlePaddle")
                            .optModelPath(Paths.get(modelPath))
                            .optModelName("mobilenet")
                            .optTranslator(translator)
                            .build();
                    model = criteria.loadModel();
//                translator = ImageClassificationTranslator.builder()
//                        .addTransform(new Resize(IMAGE_WIDTH, IMAGE_HEIGHT))
//                        .addTransform(new ToTensor())
//                        .optApplySoftmax(true)
//                        .build();
                    predictor = model.newPredictor(translator);
//                NDManager manager = NDManager.newBaseManager();
//                NDList list=null; // the input for your models as pure NDArray
//                predictor.predict(list);
                } catch (MalformedURLException ex) {
                    Logger.getLogger(CMatrix.class.getName()).log(Level.SEVERE, null, ex);
                } catch (IOException ex) {
                    Logger.getLogger(CMatrix.class.getName()).log(Level.SEVERE, null, ex);
                } catch (ModelNotFoundException ex) {
                    Logger.getLogger(CMatrix.class.getName()).log(Level.SEVERE, null, ex);
                } catch (MalformedModelException ex) {
                    Logger.getLogger(CMatrix.class.getName()).log(Level.SEVERE, null, ex);
                }

            }
        }
        return this;
    }

    public CMatrix setModelForInferenceTensorFlowJS(EnumRunTime RUNTIME, EnumOperatingSystem OS, EnumEngine engine, String modelPath, InterfaceCallBack callBackFunction, int httpServerPort, int webSocketPort) {
        if (engine == EnumEngine.TENSORFLOW_JS) {
            FactoryTensorFlowJS tjs = FactoryTensorFlowJS.getInstance();
            TENSORFLOW_JS_SERVER = tjs.startTensorFlowJS(RUNTIME, OS, modelPath, httpServerPort, webSocketPort, callBackFunction);
            icbf = callBackFunction;
        }
        return this;
    }

    public CMatrix setModelForTrain(String modelName, int NUM_CHANNEL, int IMAGE_WIDTH, int IMAGE_HEIGHT, int NUM_OUTPUT, int block_type, Block block) {
        this.NUM_CHANNEL = NUM_CHANNEL;
        this.IMAGE_WIDTH = IMAGE_WIDTH;
        this.IMAGE_HEIGHT = IMAGE_HEIGHT;
        this.NUM_OUTPUT = NUM_OUTPUT;
        this.BLOCK_TYPE = block_type;
        this.BLOCK = block;
        this.MODEL_NAME = modelName;
        System.out.println(block.getParameters().get(2).getValue().getName());
        model = FactoryDJL.getModelForTraining(modelName, block);
        return this;
    }

    public String predictWithProbabilitiesDJL() {
        Image img = ImageFactory.getInstance().fromImage(this.image);
        Classifications predictResult = null;
        try {
            predictResult = predictor.predict(img);
        } catch (TranslateException ex) {
            Logger.getLogger(CMatrix.class.getName()).log(Level.SEVERE, null, ex);
        }
        return predictResult.toString();
    }

    public String predictWithLabelDJL() {
        Image img = ImageFactory.getInstance().fromImage(this.image);
        System.out.println("img.width = " + img.getWidth() + " img.height = " + img.getHeight());
        Classifications predictResult = null;
        try {
            predictResult = predictor.predict(img);
        } catch (TranslateException ex) {
            Logger.getLogger(CMatrix.class.getName()).log(Level.SEVERE, null, ex);
        }
        String predictedLabel = predictResult.topK(1).toString().split(",")[0].split(":")[1].replace('"', ' ').trim();
        return predictedLabel;
    }

    public CMatrix trainDataSetDJL(String trainDSDir, int BATCH_SIZE, int trainRatio, int valRatio, int EPOCHS) {
        ImageFolder dataset = FactoryDJL.initDataset(trainDSDir, BATCH_SIZE, IMAGE_WIDTH, IMAGE_HEIGHT);
        try {
            RandomAccessDataset[] datasets = dataset.randomSplit(trainRatio, valRatio);
            Loss loss = Loss.softmaxCrossEntropyLoss();
            TrainingConfig config = FactoryDJL.setupTrainingConfig(loss);
            Trainer trainer = model.newTrainer(config);
            trainer.setMetrics(new Metrics());
            Shape inputShape = new Shape(1, this.NUM_CHANNEL, this.IMAGE_WIDTH, this.IMAGE_HEIGHT);
            trainer.initialize(inputShape);
            EasyTrain.fit(trainer, EPOCHS, datasets[0], datasets[1]);
            TrainingResult result = trainer.getTrainingResult();
            model.setProperty("Epoch", String.valueOf(EPOCHS));
            model.setProperty("Accuracy", String.format("%.5f", result.getValidateEvaluation("Accuracy")));
            model.setProperty("Loss", String.format("%.5f", result.getValidateLoss()));
            String path = "models/" + model.getName();
            FactoryUtils.makeDirectory(path);
            Path modelDir = Paths.get(path);
            model.save(modelDir, MODEL_NAME);
            FactoryDJL.saveSynset(modelDir, dataset.getSynset());
            TDJLModel model_info = null;
            model_info = new TDJLModel(NUM_CHANNEL, IMAGE_WIDTH, IMAGE_HEIGHT, NUM_OUTPUT, BLOCK_TYPE, BLOCK);
            FactoryDJL.saveModelParam(path + "/model_info.txt", model_info);

        } catch (IOException ex) {
            Logger.getLogger(CMatrix.class.getName()).log(Level.SEVERE, null, ex);
        } catch (TranslateException ex) {
            Logger.getLogger(CMatrix.class.getName()).log(Level.SEVERE, null, ex);
        }
        return this;
    }

    public CMatrix refresh() {
        System.gc();
        return new CMatrix();
    }

    public CMatrix clear() {
        return refresh();
    }

    public CMatrix clean() {
        return refresh();
    }

    public CMatrix savePlot(String path) {
        if (plotPanel == null) {
            System.err.println("You should call panel related commands beforehands (i.e. plot(), scatter(), scatterBlob() etc");
            return this;
        }
        ImageProcess.saveGridImage(ImageProcess.getBufferedImage(plotPanel), path);
        return this;
    }

    public CMatrix saveImageAs(String from, String to) {
        if (to.contains(".svg")) {
            ImageProcess.saveImageSVG(from, to);
            return this;
        }
        BufferedImage img = ImageProcess.readImage(from);
        ImageProcess.saveImage(img, to);
        return this;
    }

    /**
     * start camera (index=0 by default)
     *
     * @return
     */
    public CMatrix startCamera() {
        FactoryWebCam.openWebCam(0).startWebCAM();
        return this;
    }

    /**
     * start camera with index number
     *
     * @param cameraIndex : in case you have one more cameras installed type the
     * desired camera index
     * @return
     */
    public CMatrix startCamera(int cameraIndex) {
        FactoryWebCam.openWebCam(cameraIndex).startWebCAM();
        return this;
    }

    public CMatrix startCamera(int cameraIndex, java.awt.Dimension size) {
        FactoryWebCam.openWebCam(cameraIndex,size).startWebCAM();
        return this;
    }
    
    public CMatrix startCamera(int cameraIndex, java.awt.Dimension size, java.awt.Dimension resize) {
        FactoryWebCam.openWebCam(cameraIndex,size).startWebCAM(resize);
        return this;
    }

    public float[][] getArray2Dfloat() {
        return array.toFloatMatrix();
    }

    public int[][] getArray2Dint() {
        return array.toIntMatrix();
    }

    public double[][] getArray2Ddouble() {
        return array.toDoubleMatrix();
    }

    public long[][] getArray2Dlong() {
        return array.toLongMatrix();
    }

    public float[] getArray1Dfloat() {
        return array.reshape(array.length(), 1).toFloatVector();
    }

    public int[] getArray1Dint() {
        return array.reshape(array.length(), 1).toIntVector();
    }

    public long[] getArray1Dlong() {
        return array.reshape(array.length(), 1).toLongVector();
    }

    public double[] getArray1Ddouble() {
        return array.reshape(array.length(), 1).toDoubleVector();
    }

    public CMatrix dup() {
        return this.clone();
    }

    public float getFloat(int nr, int nc) {
        return array.getFloat(nr, nc);
    }

    /**
     * Image Data Augmentation For Deep & Machine Learning
     */
    public List<BufferedImage> imDataAug(int n, List<BufferedImage> imgs, DataAugmentationOpt opt) {
        List<BufferedImage> ret = new ArrayList();
        if (opt.horizontal_flip) {
            ret = ImageProcess.dataAugFlipHorizontal(imgs, n, 0.5);
        }
        if (opt.vertical_flip) {
//            ret.addAll(ImageProcess.dataAugFlipVertical(imgs,n,0.5));
            ret = ImageProcess.dataAugFlipVertical(ret, n, 0.5);
        }
        if (opt.brightness_range != null) {
            ret = ImageProcess.dataAugBrightnessRange(ret, n, opt.brightness_range);
        }
        if (opt.zoom_range != null) {
            ret = ImageProcess.dataAugZoomRange(ret, n, opt.zoom_range);
        }
        if (opt.width_shift_range != null) {
            ret = ImageProcess.dataAugWidthShiftRange(ret, n, opt.width_shift_range);
        }
        if (opt.height_shift_range != null) {
            ret = ImageProcess.dataAugHeightShiftRange(ret, n, opt.height_shift_range);
        }

        return ret;
    }

    public List<BufferedImage> dataAug(int n, List<BufferedImage> imgs, DataAugmentationOpt opt) {
        return imDataAug(n, imgs, opt);
    }

    public CMatrix getMatrixValueByIndex(int[] index) {
        float[] d = new float[index.length];
        float[] val = getArray1Dfloat();
        for (int i = 0; i < index.length; i++) {
            d[i] = val[index[i]];
        }
        setArray(d);
        return this;
    }

    public CMatrix tileImage(int nr, int nc, String destinationFolder, String fileNameTemplate, String fileExtension) {
        CMatrix cm = this.clone();
        int w = cm.getColumnNumber() / nc;
        int h = cm.getRowNumber() / nr;
        for (int i = 0; i < nr; i++) {
            for (int j = 0; j < nc; j++) {
                cm.cmd(i + ":" + (i * h), j + ":" + (j * h)).saveImage(destinationFolder + "/" + fileNameTemplate + "_" + i + "_" + j + "." + fileExtension);
            }
        }

        return this;
    }

    public CMatrix cropImages(int nr, int nc, String destinationFolder, String fileCaption, String imageExtension, boolean isShow) {
        BufferedImage img = this.getImage();
        int w = img.getWidth() / nc;
        int h = img.getHeight() / nr;
        FactoryUtils.makeDirectory(destinationFolder);
        for (int i = 0; i < nr; i++) {
            for (int j = 0; j < nc; j++) {
                BufferedImage temp = ImageProcess.cropImage(img, new CRectangle(i * h, j * w, w, h));
                ImageProcess.saveImage(temp, destinationFolder + "/" + fileCaption + "_" + i + "_" + j + "." + imageExtension);
                if (isShow) {
                    FrameImage frm = new FrameImage();
                    frm.setImage(temp, destinationFolder, fileCaption + "_" + i + "_" + j + "." + imageExtension);
                    frm.setVisible(isShow);
                }
            }
        }
        return this;
    }

    public CMatrix imageDataGenerator(String folderPath, int imageWidth, int imageHeight) {
        File[] files = FactoryUtils.getFileListInFolderForImages(folderPath);
        float[][][][] data = new float[files.length][3][imageWidth][imageWidth];
        int n = 0;
        for (File file : files) {
            //CMatrix.getInstance().imread(file).imshow();
            int k = 0;
            BufferedImage img = ImageProcess.imread(file.getAbsolutePath());
            img = ImageProcess.resize(img, imageWidth, imageHeight);

            BufferedImage img_red = ImageProcess.getRedChannelGray(img);
            float[][] imgData_red = ImageProcess.bufferedImageToArray2D(img_red);
            data[n][k++] = imgData_red;

            BufferedImage img_green = ImageProcess.getGreenChannelGray(img);
            float[][] imgData_green = ImageProcess.bufferedImageToArray2D(img_green);
            data[n][k++] = imgData_green;

            BufferedImage img_blue = ImageProcess.getBlueChannelGray(img);
            float[][] imgData_blue = ImageProcess.bufferedImageToArray2D(img_blue);
            data[n][k++] = imgData_blue;

            n++;
        }
        float[] d = FactoryUtils.flatten(data);
        CMatrix ret = new CMatrix(d);
        ret = ret.reshape(files.length, 3, imageWidth, imageHeight);
        return ret;
    }

    public CMatrix slice(int n) {
        this.array = this.array.slice(n);
        return this;
    }

    /**
     * slice n-dim array from n1 to n2
     *
     * @param n1 from
     * @param n2 to
     * @return
     */
    public CMatrix slice(int n1, int n2) {
        this.array = this.array.get(NDArrayIndex.interval(n1, n2));
        return this;
    }

    /**
     * slice n-dim array from n1 to n2 and take n3'th slice meaning reduce the
     * dimension
     *
     * @param n1 from
     * @param n2 to
     * @param n3 take this
     * @return
     */
    public CMatrix slice(int n1, int n2, int n3) {
        this.array = this.array.get(NDArrayIndex.interval(n1, n2));
        this.array = this.array.slice(n3);
        return this;
    }

    public CMatrix slice(String... code) {
        INDArrayIndex[] indexes = new INDArrayIndex[code.length];
        long[] sh = this.array.shape();
        for (int i = 0; i < code.length; i++) {
            if (code[i].contains(":")) {
                String[] s = code[i].split(":");
                if (s.length == 0) {
                    indexes[i] = NDArrayIndex.interval(0, sh[i]);
                } else if (s[0].isEmpty()) {
                    int a = Integer.parseInt(s[1]);
                    if (a >= 0) {
                        indexes[i] = NDArrayIndex.interval(0, a);
                    } else {
                        indexes[i] = NDArrayIndex.interval(0, sh[i] - Math.abs(a));
                    }

                } else if (s.length==1) {
                    int a = Integer.parseInt(s[0]);
                    if (a >= 0) {
                        indexes[i] = NDArrayIndex.interval(Integer.parseInt(s[0]), sh[i]);
                    } else {
                        indexes[i] = NDArrayIndex.interval(sh[i] - Math.abs(a), sh[i]);
                    }
                } else {
                    int a = Integer.parseInt(s[0]);
                    int b = Integer.parseInt(s[1]);
                    if (a >= 0 && b >= 0) {
                        indexes[i] = NDArrayIndex.interval(a, b);
                    } else if (a >= 0 && b < 0) {
                        indexes[i] = NDArrayIndex.interval(a, sh[i] - Math.abs(b));
                    } else if (a < 0 && b >= 0) {
                        indexes[i] = NDArrayIndex.interval(sh[i] - Math.abs(a), b);
                    } else {
                        indexes[i] = NDArrayIndex.interval(sh[i] - Math.abs(a), sh[i] - Math.abs(b));
                    }

                }
            } else if (code[i].length() >= 1) {
                if (Integer.parseInt(code[i]) >= 0) {
                    indexes[i] = NDArrayIndex.interval(Integer.parseInt(code[i]), Integer.parseInt(code[i]) + 1);
                } else {
                    int a = Math.abs(Integer.parseInt(code[i]));
                    indexes[i] = NDArrayIndex.interval(sh[i] - a, sh[i] - a+1);
                }

            }
        }
        
        this.array = this.array.get(indexes);
        return this;
    }

    public CMatrix reduce() {
        long[] sh = this.array.shape();
        List<Long> lst=new ArrayList();
        for (int i = 0; i < sh.length; i++) {
            if (sh[i]>1) {
                lst.add(sh[i]);
            }
        }
        long[] n=new long[lst.size()];
        int k=0;
        for (Long d : lst) {
            n[k++]=d;
        }
        this.array=this.array.reshape(n);
        return this;
    }

    /**
     *
     * @param imgPath : Fullpath of the image
     * @return
     */
    public CMatrix annotateImage(String imgPath) {
        this.imread(imgPath).imshow();
        return this;
    }
    
    /**
     *
     * @param folderPath : path of the image folder
     * @return
     */
    public CMatrix annotateImages(String folderPath) {
        File[] files=FactoryUtils.getFileListInFolderForImages(folderPath);
        this.imread(files[0]).imshow();
        return this;
    }

    public CMatrix reduceImageSize(String folderPath, int maxWidth, int maxHeight) {
        FactoryUtils.reduceImageSize(folderPath,maxWidth,maxHeight);
        return this;
    }

    public CMatrix convertPascalVoc2Yolo(String pathFolder, String[] labels) {
        FactoryUtils.convertPascalVoc2YoloFormat(pathFolder, labels);
        return this;
    }


}
