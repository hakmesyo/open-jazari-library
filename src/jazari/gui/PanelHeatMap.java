/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package jazari.gui;

import jazari.matrix.CMatrix;
import jazari.factory.FactoryNormalization;
import jazari.factory.FactoryUtils;
import jazari.types.TVoteMap;
import jazari.factory.FactoryColorMap;
import jazari.factory.FactoryStatistic;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.util.List;
import java.util.Map;

/**
 *
 * @author BAP1
 */
public class PanelHeatMap extends javax.swing.JPanel {

    private CMatrix cm = null;
    private Color fromColor, centerColor, toColor;
    private boolean isValueVisible = false;
    private float[][] matrixValue = null;
    private boolean isCellEdgeVisible = false;

    public Color getFromColor() {
        return fromColor;
    }

    public void setFromColor(Color fromColor) {
        this.fromColor = fromColor;
    }

    public Color getCenterColor() {
        return centerColor;
    }

    public void setCenterColor(Color centerColor) {
        this.centerColor = centerColor;
    }

    public Color getToColor() {
        return toColor;
    }

    public void setToColor(Color toColor) {
        this.toColor = toColor;
    }

    public PanelHeatMap(CMatrix cm) {
        this.cm = cm.transpose();
        repaint();
    }

    public void setMatrix(CMatrix cm) {
        this.cm = cm.transpose();
        this.matrixValue = this.cm.toFloatArray2D();
        repaint();
    }

    public CMatrix getMatrix() {
        return this.cm;
    }

    public void paint(Graphics gr1) {
        Graphics2D gr = (Graphics2D) gr1;
        gr.setRenderingHint(
                RenderingHints.KEY_TEXT_ANTIALIASING,
                RenderingHints.VALUE_TEXT_ANTIALIAS_GASP);
        Font fnt = gr.getFont();
        gr.setFont(new Font(fnt.getFontName(), 1, 18));
        gr.setColor(Color.white);
        int w = getWidth();
        int h = getHeight();
        gr.fillRect(0, 0, w, h);
        gr.setColor(Color.red);
        gr.drawRect(0, 0, w - 1, h - 1);
        gr.drawRect(1, 1, w - 3, h - 3);
        gr.setColor(Color.black);
        int px = 5;
        int py = 5;
        Rectangle rect = new Rectangle(px, py, w - 2 * px, h - 2 * py);
        drawHeatMap(gr, rect);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents


    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
    private void drawHeatMap(Graphics2D gr, Rectangle rect) {
        if (fromColor == null && centerColor == null && toColor == null) {
            //default is from blue (cold) to red (hot) color
            Color[][] colorMatrix = registerDefaultColor(cm);
            int nr = colorMatrix.length;
            int nc = colorMatrix[0].length;
            float delta_x = 1.0f * rect.width / nc;
            float delta_y = 1.0f * rect.height / nr;
            for (int i = 0; i < nr; i++) {
                for (int j = 0; j < nc; j++) {
                    gr.setColor(colorMatrix[i][j]);
                    gr.fillRect((int) (j * delta_x + rect.x), (int) (i * delta_y + rect.y), (int) (delta_x + 1), (int) (delta_y + 1));
                    if (isValueVisible) {
                        gr.setColor(switchColor(colorMatrix[i][j]));
                        gr.drawString("" + FactoryUtils.formatDouble(matrixValue[i][j]), (int) (j * delta_x + rect.x) + (int) (delta_x + 1) / 2, (int) (i * delta_y + rect.y) + (int) (delta_y + 1) / 2);
                    }
                    if (isCellEdgeVisible) {
                        gr.setColor(Color.black);
                        gr.drawRect((int) (j * delta_x + rect.x), (int) (i * delta_y + rect.y), (int) (delta_x + 1), (int) (delta_y + 1));
                    }
                }
            }
        } else if (centerColor != null) {
            //center is specified color and coldest is black and hottest is wihite
            Color[][] colorMatrix = registerCenterColor(cm, centerColor);
            int nr = colorMatrix.length;
            int nc = colorMatrix[0].length;
            float delta_x = 1.0f * rect.width / nc;
            float delta_y = 1.0f * rect.height / nr;
            for (int i = 0; i < nr; i++) {
                for (int j = 0; j < nc; j++) {
                    gr.setColor(colorMatrix[i][j]);
                    gr.fillRect((int) (j * delta_x + rect.x), (int) (i * delta_y + rect.y), (int) (delta_x + 1), (int) (delta_y + 1));
                    if (isValueVisible) {
                        gr.setColor(switchColor(colorMatrix[i][j]));
                        gr.drawString("" + FactoryUtils.formatDouble(matrixValue[i][j], 2), (int) (j * delta_x + rect.x) + (int) (delta_x + 1) / 4, (int) (i * delta_y + rect.y) + (int) (delta_y + 1) / 2);
                    }
                    if (isCellEdgeVisible) {
                        gr.setColor(Color.black);
                        gr.drawRect((int) (j * delta_x + rect.x), (int) (i * delta_y + rect.y), (int) (delta_x + 1), (int) (delta_y + 1));
                    }
                }
            }
        } else {

        }
    }

    //default is from blue (cold) to red (hot) color. At the center, green color is appeared by default in a RGB still.
    private Color[][] registerDefaultColor(CMatrix cm) {
        Color[][] col = FactoryColorMap.mapColorDefault(cm.toFloatArray2D());
        return col;
    }

    //from black(coldest) to white(hottest) around center color.
    private Color[][] registerCenterColor(CMatrix cm, Color center) {
        Color[][] col = FactoryColorMap.mapColorAroundCenterColor(cm.toFloatArray2D(), center);
        return col;
    }

    public void setShowCellEdges(boolean showCellEdge) {
        isCellEdgeVisible = showCellEdge;
        repaint();
    }

    public void setShowValue(boolean showValue) {
        isValueVisible = showValue;
        repaint();
    }

    private Color switchColor(Color col) {
        int thr=2097152;
        if ((col.getRed()+1) * (col.getGreen()+1) * (col.getBlue()+1) > 60000) {
            return Color.black;
        } else {
            return Color.white;
        }
    }

}
